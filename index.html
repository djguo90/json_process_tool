<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JSONL Â§ÑÁêÜÂ∑•ÂÖ∑</title>
  <style>
    :root{
      --app-bg:#f6f7fb;
      --panel:#ffffff;
      --panel-2:#fbfcff;
  
      --text:#0f172a;
      --muted:#64748b;
  
      --border:rgba(15,23,42,.12);
      --border-2:rgba(15,23,42,.08);
  
      --accent:#2563eb;
      --accent-2:#1d4ed8;
      --accent-bg:rgba(37,99,235,.10);
  
      --ok-bg:rgba(34,197,94,.10);
      --ok-border:rgba(34,197,94,.35);
  
      --shadow-sm:0 1px 2px rgba(0,0,0,.06);
      --shadow:0 1px 2px rgba(0,0,0,.05), 0 12px 28px rgba(0,0,0,.08);
  
      --radius:14px;
      --radius-sm:12px;
      --radius-xs:10px;
  
      --focus:0 0 0 3px rgba(37,99,235,.18);
    }
  
    *{ box-sizing:border-box; }
    html, body{
      margin:0; padding:0; height:100%;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","PingFang SC","Microsoft YaHei",sans-serif;
      font-size:14px;
      color:var(--text);
      background:var(--app-bg);
    }
  
    /* App Layout */
    #app{
      height:100vh;
      display:flex;
      flex-direction:column;
    }
  
    /* Top Bar */
    #top-bar{
      flex:0 0 auto;
      padding:10px 12px;
      border-bottom:1px solid var(--border-2);
      background:rgba(255,255,255,.86);
      backdrop-filter:saturate(180%) blur(10px);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      position:sticky;
      top:0;
      z-index:50;
    }
    #top-bar .left{
      font-weight:800;
      letter-spacing:.2px;
      color:var(--text);
    }
    #top-bar .right{
      display:flex;
      align-items:center;
      flex-wrap:wrap;
      gap:8px;
    }
  
    /* Buttons (only style, no behavior changes) */
    button{
      appearance:none;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      padding:7px 10px;
      border-radius:10px;
      cursor:pointer;
      box-shadow:var(--shadow-sm);
      transition:transform .08s ease, box-shadow .15s ease, background .15s ease, border-color .15s ease;
      user-select:none;
    }
    button:hover{
      background:var(--panel-2);
      border-color:rgba(37,99,235,.35);
      box-shadow:0 8px 20px rgba(0,0,0,.10);
    }
    button:active{
      transform:translateY(1px);
      box-shadow:var(--shadow-sm);
    }
    button:focus-visible{
      outline:none;
      box-shadow:var(--shadow-sm), var(--focus);
      border-color:rgba(37,99,235,.55);
    }
  
    /* Make "ÊâãÂä®‰øùÂ≠ò" feel primary without changing id/behavior */
    #btn-save{
      background:var(--accent);
      border-color:var(--accent);
      color:#fff;
    }
    #btn-save:hover{ background:var(--accent-2); border-color:var(--accent-2); }
  
    /* Main 4-column grid */
    #main{
      flex:1 1 auto;
      display:grid;
      grid-template-columns: var(--col1, 24.5%) 6px var(--col2, 24.5%) 6px var(--col3, 24.5%) 6px var(--col4, 24.5%);
      overflow:hidden;
      padding:12px;
      gap:0;
    }
  
    .column{
      display:flex;
      flex-direction:column;
      overflow:hidden;
      background:var(--panel);
      border:1px solid var(--border-2);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      min-width:0;
    }
    .column-header{
      flex:0 0 auto;
      padding:10px 12px;
      font-weight:800;
      border-bottom:1px solid var(--border-2);
      background:linear-gradient(to bottom, #ffffff, #f8fafc);
    }
    .column-content{
      flex:1 1 auto;
      padding:10px;
      overflow:auto;
    }
  
    /* Scrollbar (WebKit) */
    .column-content::-webkit-scrollbar{ width:10px; height:10px; }
    .column-content::-webkit-scrollbar-track{ background:transparent; }
    .column-content::-webkit-scrollbar-thumb{
      background:rgba(15,23,42,.18);
      border-radius:999px;
      border:3px solid transparent;
      background-clip:content-box;
    }
    .column-content::-webkit-scrollbar-thumb:hover{
      background:rgba(15,23,42,.28);
      border:3px solid transparent;
      background-clip:content-box;
    }
  
    /* Resize handles */
    .resize-handle{
      cursor:col-resize;
      background:transparent;
      position:relative;
    }
    .resize-handle::before{
      content:"";
      position:absolute;
      left:2px;
      top:14px;
      bottom:14px;
      width:2px;
      border-radius:999px;
      background:rgba(15,23,42,.18);
      transition:background .15s ease, transform .15s ease;
    }
    .resize-handle:hover::before{
      background:rgba(37,99,235,.55);
      transform:scaleX(1.2);
    }
  
    /* ===== Task tree ===== */
    .tree-row{
      display:flex;
      align-items:center;
      gap:6px;
      padding:7px 8px;
      border-radius:10px;
      user-select:none;
    }
    .tree-row.task-row{ cursor:pointer; }
    .tree-row:hover{ background:rgba(15,23,42,.04); }
    .tree-row.task-row.active{
      background:var(--accent-bg);
      box-shadow:0 0 0 1px rgba(37,99,235,.25) inset;
    }
  
    .tree-row.dragging{ opacity:0.6; }
    .tree-row.drag-over-top{ box-shadow:0 -2px 0 0 var(--accent); }
    .tree-row.drag-over-bottom{ box-shadow:0 2px 0 0 var(--accent); }
  
    .tree-arrow{
      width:18px;
      height:18px;
      display:inline-flex;
      justify-content:center;
      align-items:center;
      font-size:13px;
      cursor:pointer;
      border-radius:6px;
      color:var(--muted);
    }
    .tree-arrow.placeholder{ visibility:hidden; cursor:default; }
    .tree-arrow:not(.placeholder):hover{
      background:rgba(15,23,42,.06);
      color:var(--text);
    }
  
    .tree-name{
      flex:1;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-weight:600;
    }
    /* little icons (purely visual) */
    .tree-row[data-node-type="directory"] .tree-name::before{
      content:"üìÅ";
      margin-right:6px;
      opacity:.9;
    }
    .tree-row[data-node-type="task"] .tree-name::before{
      content:"üß©";
      margin-right:6px;
      opacity:.9;
    }
  
    /* ===== File groups & paths ===== */
    .file-group{
      border:1px solid var(--border-2);
      border-radius:var(--radius);
      margin-bottom:10px;
      background:var(--panel);
      box-shadow:var(--shadow-sm);
      overflow:hidden;
      transition:box-shadow .15s ease, transform .15s ease, border-color .15s ease;
    }
    .file-group:hover{
      box-shadow:0 10px 24px rgba(0,0,0,.10);
      border-color:rgba(37,99,235,.22);
    }
    .file-group-header{
      padding:9px 10px;
      display:flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      border-bottom:1px solid var(--border-2);
      background:linear-gradient(to bottom, #ffffff, #f8fafc);
    }
    .file-group-title{
      flex:1;
      font-weight:800;
    }
    .file-group-body{ padding:10px; background:var(--panel); }
  
    .file-path-row{
      padding:9px 10px;
      border-radius:12px;
      margin-bottom:6px;
      cursor:pointer;
      border:1px solid transparent;
      transition:background .15s ease, border-color .15s ease;
    }
    .file-path-row:hover{ background:rgba(15,23,42,.04); }
    .file-path-row.active{
      background:var(--accent-bg);
      border-color:rgba(37,99,235,.25);
    }
  
    .file-path-main{ display:block; }
    .file-path-text{
      display:block;
      white-space:normal;
      word-break:break-all;
      font-weight:600;
    }
    .file-path-info{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin-top:4px;
      margin-left:0;
    }
  
    .file-group.dragging{ opacity:0.6; }
    .file-group.drag-over-top{ box-shadow:0 -2px 0 0 var(--accent); }
    .file-group.drag-over-bottom{ box-shadow:0 2px 0 0 var(--accent); }
  
    /* ===== Field structure ===== */
    .field-structure-empty{
      color:var(--muted);
      padding:6px 2px;
    }
  
    .field-row{
      display:flex;
      align-items:center;
      gap:6px;
      padding:7px 8px;
      border-radius:10px;
    }
    .field-row:hover{ background:rgba(15,23,42,.04); }
  
    .field-toggle{
      width:18px;
      height:18px;
      display:inline-flex;
      justify-content:center;
      align-items:center;
      font-size:13px;
      cursor:pointer;
      border-radius:6px;
      color:var(--muted);
    }
    .field-toggle:hover{ background:rgba(15,23,42,.06); color:var(--text); }
    .field-toggle.empty{ visibility:hidden; cursor:default; }
  
    .field-name{
      cursor:pointer;
      margin-right:4px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      flex:1;
      font-weight:650;
    }
    .field-type{
      font-size:12px;
      color:var(--muted);
      margin-left:4px;
      white-space:nowrap;
      background:rgba(15,23,42,.04);
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(15,23,42,.06);
    }
    .field-children{
      margin-left:14px;
      padding-left:10px;
      border-left:1px dashed rgba(15,23,42,.18);
    }
  
    /* ===== Operation boards ===== */
    .sequence-board{
      border:1px solid var(--border-2);
      border-radius:var(--radius);
      margin-bottom:12px;
      background:var(--panel);
      box-shadow:var(--shadow-sm);
      overflow:hidden;
      transition:box-shadow .15s ease, transform .15s ease, border-color .15s ease;
    }
    .sequence-board:hover{
      box-shadow:0 12px 26px rgba(0,0,0,.10);
      border-color:rgba(37,99,235,.22);
    }
  
    .sequence-header{
      padding:9px 10px;
      display:flex;
      align-items:flex-start;
      gap:8px;
      cursor:pointer;
      border-bottom:1px solid var(--border-2);
      background:linear-gradient(to bottom, #a4e5f9, #a4e5f9);
    }
  
    /* Keep your original title DOM; just modernize look */
    .sequence-title{
      flex:1;
      font-weight:700;
      padding:0;
      border-radius:0;
      background:transparent;
    }
    .sequence-title-main{
      display:block;
      font-weight:900;
      letter-spacing:.2px;
    }
    .sequence-code-path{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin-top:4px;
      white-space:normal;
      word-break:break-all;
    }
  
    .sequence-meta{
      padding:10px;
      border-bottom:1px solid var(--border-2);
      background:var(--panel);
    }
    .sequence-meta label{
      display:block;
      margin-bottom:8px;
      color:var(--muted);
      font-size:12px;
    }
  
    input, textarea{
      width:100%;
      border:1px solid var(--border);
      border-radius:10px;
      padding:8px 10px;
      background:#fff;
      color:var(--text);
      outline:none;
      transition:border-color .15s ease, box-shadow .15s ease, background .15s ease;
      font-family:inherit;
    }
    textarea{ font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; }
  
    input:focus, textarea:focus{
      border-color:rgba(37,99,235,.55);
      box-shadow:var(--focus);
    }
  
    .sequence-meta button{
      margin-top:6px;
    }
  
    .sequence-nodes{
      padding:10px;
    }
  
    .sequence-node{
      border-radius:14px;
      padding:10px 10px;
      margin-bottom:8px;
      border:1px solid var(--border-2);
      background:#fff;
      box-shadow:var(--shadow-sm);
      transition:box-shadow .15s ease, border-color .15s ease, transform .08s ease;
    }
    .sequence-node:hover{
      border-color:rgba(37,99,235,.18);
      box-shadow:0 10px 22px rgba(0,0,0,.10);
    }
  
    .sequence-node-main{
      display:flex;
      justify-content:space-between;
      align-items:center;
      cursor:pointer;
      gap:8px;
    }
    .sequence-node-title{ font-weight:900; }
    .sequence-node-type{
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      background:rgba(15,23,42,.04);
      border:1px solid rgba(15,23,42,.06);
      padding:2px 8px;
      border-radius:999px;
    }
  
    .sequence-node-block{ width:100%; margin-bottom:8px; }
    .sequence-node-children{
      margin-top:10px;
      display:flex;
      gap:10px;
    }
    .sequence-node-branch{
      flex:1;
      min-width:0;
      padding-left:10px;
      position:relative;
    }
    .sequence-node-branch::before{
      content:"";
      position:absolute;
      left:0;
      top:0;
      bottom:0;
      width:2px;
      border-radius:999px;
      background:rgba(15,23,42,.08);
    }
  
    .sequence-node-edit{
      margin-top:10px;
      padding-top:10px;
      border-top:1px dashed rgba(15,23,42,.18);
      display:none;
    }
    .sequence-node-edit label{
      display:block;
      margin-bottom:8px;
      color:var(--muted);
      font-size:12px;
    }
    .sequence-node-edit textarea{ min-height:86px; resize:vertical; }
  
    .sequence-node.highlight{
      box-shadow:0 0 0 2px rgba(37,99,235,.30) inset, var(--shadow-sm);
    }
  
    /* Executed nodes */
    .sequence-node.executed{
      background:var(--ok-bg);
      border-color:var(--ok-border);
    }
  
    /* Result path line */
    .sequence-node-result-path{
      font-size:12px;
      color:var(--muted);
      margin-top:6px;
      white-space:normal;
      word-break:break-all;
    }
  
    /* Frozen */
    .sequence-node.frozen{
      opacity:0.65;
      filter:grayscale(100%);
      background:#f8fafc;
      border-color:var(--border);
    }
    .sequence-node.frozen .sequence-node-title::after{
      content:" (Â∑≤ÂÜªÁªì)";
      font-size:12px;
      color:var(--muted);
      margin-left:6px;
      font-weight:700;
    }
  
    /* Board dragging indicators */
    .sequence-board.dragging{ opacity:0.6; }
    .sequence-board.drag-over-top{ box-shadow:0 -2px 0 0 var(--accent); }
    .sequence-board.drag-over-bottom{ box-shadow:0 2px 0 0 var(--accent); }
  
    /* ===== Context menu ===== */
    #context-menu{
      position:fixed;
      z-index:9999;
      min-width:160px;
      background:#fff;
      border-radius:14px;
      box-shadow:0 18px 50px rgba(0,0,0,.22);
      border:1px solid var(--border-2);
      display:none;
      font-size:13px;
      padding:6px;
    }
    .context-menu-item{
      padding:9px 10px;
      cursor:pointer;
      white-space:nowrap;
      border-radius:10px;
      color:var(--text);
      transition:background .12s ease;
    }
    .context-menu-item:hover{
      background:var(--accent-bg);
    }
    .context-menu-divider{
      height:1px;
      background:rgba(15,23,42,.08);
      margin:6px 4px;
    }
  
    /* Hint */
    .hint{
      font-size:12px;
      color:var(--muted);
      margin-top:8px;
      padding:10px 10px;
      border:1px dashed rgba(15,23,42,.18);
      border-radius:12px;
      background:rgba(255,255,255,.65);
    }
  
    @media (prefers-reduced-motion: reduce){
      *{ transition:none !important; }
    }
  </style>  
</head>
<body>
<div id="app">
  <div id="top-bar">
    <div class="left">JSONL ‰ªªÂä°Â§ÑÁêÜÂ∑•ÂÖ∑</div>
    <div class="right">
      <button id="btn-task-vars">‰ªªÂä°ÂèòÈáè</button>
      <button id="btn-undo">Êí§ÈîÄ</button>
      <button id="btn-redo">ÈáçÂÅö</button>
      <button id="btn-save">ÊâãÂä®‰øùÂ≠ò</button>
      <button id="btn-reload">ÈáçÊñ∞Âä†ËΩΩ</button>
    </div>
  </div>

  <div id="main">
    <!-- Á¨¨‰∏ÄÂàóÔºöÁõÆÂΩïÂèä‰ªªÂä°ÁÆ°ÁêÜ -->
    <div class="column" id="col-1">
      <div class="column-header">ÁõÆÂΩï &amp; ‰ªªÂä°ÁÆ°ÁêÜ</div>
      <div class="column-content" id="task-tree"></div>
    </div>
    <div class="resize-handle" data-handle="1"></div>

    <!-- Á¨¨‰∫åÂàóÔºö‰ªªÂä°ËæìÂÖ•ÔºàÊñá‰ª∂ÁªÑÔºâ -->
    <div class="column" id="col-2">
      <div class="column-header">‰ªªÂä°ËæìÂÖ•ÔºàÊñá‰ª∂ÁªÑÔºâ</div>
      <div class="column-content" id="file-groups"></div>
    </div>
    <div class="resize-handle" data-handle="2"></div>

    <!-- Á¨¨‰∏âÂàóÔºöÊï∞ÊçÆÁªìÊûÑÂ±ïÁ§∫ -->
    <div class="column" id="col-3">
      <div class="column-header">Êï∞ÊçÆÁªìÊûÑÂ±ïÁ§∫</div>
      <div class="column-content" id="field-structure"></div>
    </div>
    <div class="resize-handle" data-handle="3"></div>

    <!-- Á¨¨ÂõõÂàóÔºöÊìç‰ΩúÂå∫ -->
    <div class="column" id="col-4">
      <div class="column-header">Êìç‰ΩúÂ∫èÂàóÁîªÊùø</div>
      <div class="column-content" id="operation-area"></div>
    </div>
  </div>
</div>

<!-- ÈÄöÁî®Âè≥ÈîÆËèúÂçï -->
<!-- ‰ªªÂä°ÂèòÈáèÁºñËæëÂºπÁ™óÔºötextarea ÂèØÊãñÂä®ÊîπÂ§ßÂ∞è -->
<div id="taskvars-modal" style="display:none; position:fixed; inset:0; z-index:10000;">
  <div id="taskvars-backdrop" style="position:absolute; inset:0; background:rgba(0,0,0,.35);"></div>

  <div style="
      position:relative;
      width:min(900px,92vw);
      max-height:90vh;
      margin:auto;
      background:#fff;
      border:1px solid rgba(15,23,42,.12);
      border-radius:12px;
      box-shadow:0 30px 80px rgba(0,0,0,.25);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    ">
    <div style="padding:10px 12px; border-bottom:1px solid rgba(15,23,42,.08); font-weight:800; display:flex; justify-content:space-between; align-items:center;">
      <div>ÁºñËæë‰ªªÂä°ÂèòÈáèÔºàJSON ÂØπË±°Ôºâ</div>
      <button id="taskvars-close">ÂÖ≥Èó≠</button>
    </div>

    <div style="padding:12px; overflow:auto;">
      <textarea id="taskvars-textarea"
        spellcheck="false"
        style="
          width:100%;
          min-height:260px;
          resize:both;       /* ‚úÖ ÂèØÊãñÂä®‰ªªÊÑèÊñπÂêë */
          overflow:auto;
          box-sizing:border-box;
          font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace;
          font-size:13px;
          line-height:1.35;
          border:1px solid rgba(15,23,42,.12);
          border-radius:10px;
          padding:10px;
        "></textarea>

      <div style="margin-top:8px; color:#64748b; font-size:12px;">
        ÂèØÊãñÂä®Âè≥‰∏ãËßíÊîπÂèòÂ§ßÂ∞è„ÄÇ‰øùÂ≠òÊó∂‰ºö JSON.parse Ê†°È™åÔºàÂ§±Ë¥•Âàô‰∏ç‰øùÂ≠òÔºâ„ÄÇ
      </div>
    </div>

    <div style="padding:10px 12px; border-top:1px solid rgba(15,23,42,.08); display:flex; justify-content:flex-end; gap:8px;">
      <button id="taskvars-cancel">ÂèñÊ∂à</button>
      <button id="taskvars-save">‰øùÂ≠ò</button>
    </div>
  </div>
</div>

<div id="context-menu"></div>

<datalist id="function-names">
  <option value="delete_fields"></option>
  <option value="rename_fields"></option>
  <option value="remove_duplicates_interior"></option>
  <option value="remove_duplicates_exterior"></option>
  <option value="has_key_path"></option>
</datalist>

<script>
  // ===========
  // ÂÖ®Â±ÄÁä∂ÊÄÅ
  // ===========

  let appState = {
    directories: {},
    tasks: {},
    file_groups: {},
    operation_sequences: {}
  };

  let uiState = {
    currentTaskId: null,
    selectedFilePathId: null,
    fieldStructure: null
  };

  const colWidthsKey = "jsonl_tool_column_widths_v1";

    // ===========
  // Êí§ÈîÄ / ÈáçÂÅö Áõ∏ÂÖ≥
  // ===========

  const HISTORY_LIMIT = 50; // ÊúÄÂ§ö‰øùÁïô 50 Ê≠•
  let historyStack = [];    // ÊØè‰∏ÄÈ°πÊòØ‰∏Ä‰∏™ appState Âø´ÁÖß
  let historyIndex = -1;    // ÊåáÂêëÂΩìÂâçÁä∂ÊÄÅÂú® historyStack ‰∏≠ÁöÑÁ¥¢Âºï
  let isRestoringHistory = false; // Èò≤Ê≠¢Êí§ÈîÄ/ÈáçÂÅöÊó∂ÂÜçÊ¨°ËÆ∞ÂéÜÂè≤
  
  let currentVersion = 0;     // ÊòæÂºèÂ£∞ÊòéÔºåÈÅøÂÖç ReferenceError
  let stateLoaded = false;    // Ê≤°Âä†ËΩΩÂÆå‰∏çÂÖÅËÆ∏‰øùÂ≠ò
  let saveInFlight = false;   // Èò≤Ê≠¢Âπ∂Âèë‰øùÂ≠ò
  let savePending = false;    // inFlight Êó∂ÂèàÊù•‰∏ÄÊ¨°‰øùÂ≠òÔºåÊ†áËÆ∞Ë°•‰∏ÄÂàÄ



  function cloneState(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  // ÂàùÂßãÂåñÂéÜÂè≤Ê†àÔºöÊääÂΩìÂâç appState ‰Ωú‰∏∫‚ÄúÁ¨¨ 0 Ê≠•‚Äù
  function initHistoryWithCurrentState() {
    historyStack = [cloneState(appState)];
    historyIndex = 0;
  }

  function canUndo() {
    return historyIndex > 0;
  }

  function canRedo() {
    return historyIndex >= 0 && historyIndex < historyStack.length - 1;
  }

  // Âú®ÊØèÊ¨°ÁúüÊ≠£‰øÆÊîπÂÆå appState ÂêéË∞ÉÁî®ÔºàÁî± scheduleSaveState Ëá™Âä®Ëß¶ÂèëÔºâ
  function recordHistorySnapshot() {
    if (isRestoringHistory) return;

    // Â¶ÇÊûú‰πãÂâçÊâßË°åËøá undoÔºåhistoryIndex ÂèØËÉΩ‰∏çÂú®Êú´Â∞æÔºåÈúÄË¶ÅÊà™Êñ≠‚ÄúÊú™Êù•ÂàÜÊîØ‚Äù
    if (historyIndex < historyStack.length - 1) {
      historyStack = historyStack.slice(0, historyIndex + 1);
    }

    historyStack.push(cloneState(appState));
    if (historyStack.length > HISTORY_LIMIT) {
      // Ë∂ÖÂá∫‰∏äÈôêÊó∂‰∏¢ÊéâÊúÄÊó©ÁöÑ‰∏ÄÊ≠•ÔºåÂπ∂Êää historyIndex Ë∞ÉÊï¥Âà∞ÊúÄÂêé
      historyStack.shift();
      historyIndex = historyStack.length - 1;
    } else {
      historyIndex++;
    }
  }

  function restoreFromHistory(targetIndex) {
    if (targetIndex < 0 || targetIndex >= historyStack.length) return;
    const snapshot = historyStack[targetIndex];

    isRestoringHistory = true;
    appState = cloneState(snapshot);
    isRestoringHistory = false;
    historyIndex = targetIndex;

    // ‰øÆÊ≠£ UI Áä∂ÊÄÅÔºàÈò≤Ê≠¢ÂΩìÂâç‰ªªÂä°Ë¢´Âà†ÊéâÔºâ
    if (uiState.currentTaskId && !appState.tasks[uiState.currentTaskId]) {
      const firstTask = Object.values(appState.tasks || {})[0];
      uiState.currentTaskId = firstTask ? firstTask.id : null;
    }
    uiState.selectedFilePathId = null;
    uiState.fieldStructure = null;

    renderAll();
    // Êí§ÈîÄ/ÈáçÂÅö‰πãÂêéÔºå‰ªçÁÑ∂Ë¶ÅÊääÁä∂ÊÄÅÂêåÊ≠•ÂõûÂêéÁ´ØÔºå‰ΩÜ‰∏çÂÜçËÆ∞ÂΩïÊñ∞ÂéÜÂè≤
    scheduleSaveState(true);
  }

  function undoLastOperation() {
    if (!canUndo()) {
      showMessage("Ê≤°ÊúâÂèØ‰ª•Êí§ÈîÄÁöÑÊìç‰Ωú„ÄÇ");
      return;
    }
    restoreFromHistory(historyIndex - 1);
  }

  function redoLastOperation() {
    if (!canRedo()) {
      showMessage("Ê≤°ÊúâÂèØ‰ª•ÈáçÂÅöÁöÑÊìç‰Ωú„ÄÇ");
      return;
    }
    restoreFromHistory(historyIndex + 1);
  }


  // ===========
  // Â∑•ÂÖ∑ÂáΩÊï∞
  // ===========

  function rewriteRefsInParamsJson(paramsJson, rewriteFn) {
    if (typeof paramsJson !== "string") return paramsJson;

    let obj;
    try {
      obj = JSON.parse(paramsJson);
    } catch {
      // ‰Ω†ÂÖÅËÆ∏ params_json ÈùûÊ≥ïÊó∂‰πü‰øùÂ≠òÂ≠óÁ¨¶‰∏≤ÔºöÈÇ£Â∞±‰∏çË¶ÅÂä®ÂÆÉ
      return paramsJson;
    }

    function walk(x) {
      if (!x || typeof x !== "object") return x;
      if (Array.isArray(x)) return x.map(walk);

      // ÂëΩ‰∏≠ {$ref: {...}}
      if (x.$ref && typeof x.$ref === "object" && !Array.isArray(x.$ref)) {
        const newRef = rewriteFn(x.$ref);
        if (newRef) {
          return { ...x, $ref: newRef };
        }
      }

      // ÊôÆÈÄö object Ê∑±Â∫¶ÈÅçÂéÜ
      const out = {};
      for (const k in x) out[k] = walk(x[k]);
      return out;
    }

    const rewritten = walk(obj);
    return JSON.stringify(rewritten, null, 2);
  }

  function insertTextAtCursor(textarea, text) {
    textarea.focus();
    const start = textarea.selectionStart ?? textarea.value.length;
    const end = textarea.selectionEnd ?? textarea.value.length;
    const before = textarea.value.slice(0, start);
    const after = textarea.value.slice(end);
    textarea.value = before + text + after;
    const newPos = start + text.length;
    textarea.selectionStart = textarea.selectionEnd = newPos;
    // Ëß¶Âèë input ‰∫ã‰ª∂ÔºåËÆ©‰Ω†Áé∞ÊúâÁöÑ‚ÄúÂÆûÊó∂‰øùÂ≠ò‚ÄùÈÄªËæëÁîüÊïà
    textarea.dispatchEvent(new Event("input", { bubbles: true }));
  }

  function promptPickFromList(title, items, renderLine) {
    if (!items.length) {
      showMessage("Ê≤°ÊúâÂèØÈÄâÈ°π„ÄÇ");
      return null;
    }
    const lines = items.map((it, i) => `${i + 1}. ${renderLine(it)}`);
    const input = prompt(
      `${title}\n\n` + lines.join("\n") + `\n\nËØ∑ËæìÂÖ•Â∫èÂè∑Ôºà1-${items.length}ÔºâÔºö`,
      "1"
    );
    if (!input) return null;
    const idx = parseInt(input, 10);
    if (Number.isNaN(idx) || idx < 1 || idx > items.length) {
      showMessage("Â∫èÂè∑‰∏çÂêàÊ≥ï„ÄÇ");
      return null;
    }
    return items[idx - 1];
  }

  function listAllFileGroups() {
    const out = [];
    for (const gid in (appState.file_groups || {})) {
      const g = appState.file_groups[gid];
      const t = appState.tasks?.[g.task_id];
      out.push({
        id: g.id,
        name: g.name,
        task_id: g.task_id,
        task_name: t ? t.name : "(Êú™Áü•‰ªªÂä°)"
      });
    }
    // Á®çÂæÆÊéíÂ∫è‰∏Ä‰∏ãÔºåÊñπ‰æøÊâæ
    out.sort((a, b) => (a.task_name + a.name).localeCompare(b.task_name + b.name, "zh-CN"));
    return out;
  }

  function listAllFilePaths() {
    const out = [];
    for (const gid in (appState.file_groups || {})) {
      const g = appState.file_groups[gid];
      const t = appState.tasks?.[g.task_id];
      (g.file_paths || []).forEach(fp => {
        out.push({
          id: fp.id,
          path: fp.path,
          group_id: g.id,
          group_name: g.name,
          task_id: g.task_id,
          task_name: t ? t.name : "(Êú™Áü•‰ªªÂä°)"
        });
      });
    }
    return out;
  }

  function listAllNodeOutputs() {
    const out = [];
    for (const sid in (appState.operation_sequences || {})) {
      const seq = appState.operation_sequences[sid];
      const t = appState.tasks?.[seq.task_id];
      const g = appState.file_groups?.[seq.file_group_id];
      (seq.nodes || []).forEach(n => {
        if (n.node_type !== "op") return;
        const p = (n.result_save_path || "").trim();
        if (!p) return; // Ê≤°ÊúâËæìÂá∫Ë∑ØÂæÑÂ∞±‰∏çÂàóÂá∫
        out.push({
          sequence_id: seq.id,
          sequence_name: seq.name,
          task_id: seq.task_id,
          task_name: t ? t.name : "(Êú™Áü•‰ªªÂä°)",
          file_group_name: g ? g.name : "(Êú™Áü•Êñá‰ª∂ÁªÑ)",
          node_id: n.id,
          node_name: n.name || "(Êú™ÂëΩÂêçËäÇÁÇπ)",
          result_save_path: p
        });
      });
    }
    // Êõ¥Â•ΩÊâæÔºöÊåâ task / seq / node ÊéíÂ∫è
    out.sort((a, b) => (a.task_name + a.sequence_name + a.node_name).localeCompare(b.task_name + b.sequence_name + b.node_name, "zh-CN"));
    return out;
  }

  function buildRefSnippet(refObj) {
    // Áªü‰∏ÄËæìÂá∫Â∏¶Áº©ËøõÁöÑÁâáÊÆµÔºåÊèíÂÖ•Âà∞ params Êó∂Êõ¥ÂèØËØª
    return JSON.stringify({ "$ref": refObj }, null, 2);
  }

  function createId() {
    return (
      Date.now().toString(36) +
      Math.random().toString(36).substring(2, 8)
    );
  }

  function showMessage(msg) {
    alert(msg);
  }

  function copyToClipboard(text) {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(() => {
        console.log("Copied:", text);
      }).catch(() => {
        showMessage("Â§çÂà∂Â§±Ë¥•ÔºåËØ∑ÊâãÂä®Â§çÂà∂„ÄÇ");
      });
    } else {
      const textarea = document.createElement("textarea");
      textarea.value = text;
      document.body.appendChild(textarea);
      textarea.select();
      try {
        document.execCommand("copy");
      } catch (e) {
        console.error(e);
      }
      document.body.removeChild(textarea);
    }
  }

  function saveWidthsToLocal(widths) {
    localStorage.setItem(colWidthsKey, JSON.stringify(widths));
  }

  function loadWidthsFromLocal() {
    const raw = localStorage.getItem(colWidthsKey);
    if (!raw) return null;
    try {
      const arr = JSON.parse(raw);
      if (Array.isArray(arr) && arr.length === 4) return arr;
    } catch (e) {}
    return null;
  }

  function applyColumnWidths(widths) {
    document.documentElement.style.setProperty("--col1", widths[0] + "%");
    document.documentElement.style.setProperty("--col2", widths[1] + "%");
    document.documentElement.style.setProperty("--col3", widths[2] + "%");
    document.documentElement.style.setProperty("--col4", widths[3] + "%");
  }

  function getCurrentColumnWidths() {
    const cs = getComputedStyle(document.documentElement);
    function parseVar(name) {
      const v = cs.getPropertyValue(name) || "25%";
      const num = parseFloat(v);
      return isNaN(num) ? 25 : num;
    }
    return [
      parseVar("--col1"),
      parseVar("--col2"),
      parseVar("--col3"),
      parseVar("--col4"),
    ];
  }

  function generateUniqueName(base, existingNames) {
    if (!existingNames.includes(base)) return base;
    let i = 1;
    while (true) {
      const candidate = base + " " + i;
      if (!existingNames.includes(candidate)) return candidate;
      i++;
    }
  }

  // ========= ‰ªªÂä°Á∫ßÂèòÈáèÁõ∏ÂÖ≥Â∑•ÂÖ∑ =========

  function getTaskVars(taskId) {
    if (!taskId) return {};
    const t = appState.tasks[taskId];
    if (!t || !t.vars || typeof t.vars !== "object") return {};
    return t.vars;
  }

  // ÊîØÊåÅÂú®Â≠óÁ¨¶‰∏≤‰∏≠ÂÜô {{key}} Âç†‰ΩçÁ¨¶ÔºåÁî®ÂΩìÂâç‰ªªÂä°ÁöÑ vars ÊõøÊç¢
  function resolveTaskVarsInString(str, taskId) {
    if (!str || typeof str !== "string") return str;
    const vars = getTaskVars(taskId);
    return str.replace(/\{\{(\w+)\}\}/g, (match, key) => {
      if (Object.prototype.hasOwnProperty.call(vars, key)) {
        return vars[key];
      }
      return match; // Ê≤°ÊúâÂØπÂ∫îÂèòÈáèÂ∞±ÂéüÊ†∑ËøîÂõû
    });
  }

  function getCurrentTask() {
    if (!uiState.currentTaskId) return null;
    return appState.tasks[uiState.currentTaskId] || null;
  }

  function findFilePathById(filePathId) {
    for (const groupId in appState.file_groups) {
      const group = appState.file_groups[groupId];
      const fp = (group.file_paths || []).find(p => p.id === filePathId);
      if (fp) return { group, filePath: fp };
    }
    return null;
  }

  function sequenceNodesForTask(taskId) {
    return Object.values(appState.operation_sequences).filter(
      seq => seq.task_id === taskId
    );
  }

  function groupsForTask(taskId) {
    return Object.values(appState.file_groups || {}).filter(
      g => g.task_id === taskId
    );
  }

  function getSeqAndNode(seqId, nodeId) {
    const seq = appState.operation_sequences[seqId];
    if (!seq || !Array.isArray(seq.nodes)) return { seq: null, node: null };
    const node = seq.nodes.find(n => n.id === nodeId) || null;
    return { seq, node };
  }

  // Êää targetId ÂèäÂÖ∂ÊâÄÊúâÂêé‰ª£ÁöÑ executed ËÆæ‰∏∫ val
  function setExecutedForNodeAndDescendants(seq, targetId, val) {
    if (!seq || !Array.isArray(seq.nodes)) return;
    const nodes = seq.nodes;

    function dfs(id) {
      const cur = nodes.find(n => n.id === id);
      if (cur) cur.executed = val;
      nodes.filter(n => n.parent_id === id).forEach(ch => dfs(ch.id));
    }
    dfs(targetId);
  }

  // Êää targetId ÁöÑÊâÄÊúâÁ•ñÂÖà executed ËÆæ‰∏∫ true
  function setExecutedTrueForAncestors(seq, targetId) {
    if (!seq || !Array.isArray(seq.nodes)) return;
    const nodes = seq.nodes;

    let cur = nodes.find(n => n.id === targetId);
    while (cur && cur.parent_id) {
      const p = nodes.find(n => n.id === cur.parent_id);
      if (!p) break;
      p.executed = true;
      cur = p;
    }
  }

  // ÂØπÂ§ñÔºöËÆæÁΩÆ executedÔºåÂπ∂ÂÅö‰Ω†Ë¶ÅÁöÑ‰º†Êí≠ËßÑÂàô
  function setNodeExecutedWithPropagation(seqId, nodeId, newVal) {
    const { seq, node } = getSeqAndNode(seqId, nodeId);
    if (!seq || !node) return;

    if (newVal === false) {
      // ËßÑÂàôÔºöfalse => Ëá™Â∑±+Â≠êÊ†ëÂÖ® false
      setExecutedForNodeAndDescendants(seq, nodeId, false);
    } else {
      // ËßÑÂàôÔºötrue => Ëá™Â∑± true + Áà∂ÈìæÂÖ® true
      node.executed = true;
      setExecutedTrueForAncestors(seq, nodeId);
    }

    scheduleSaveState();      // Áî®Êà∑Êìç‰ΩúÔºöËøõÊí§ÈîÄÊ†à
  }

  // ========== Êñá‰ª∂ÁªÑÈ°∫Â∫èÁÆ°ÁêÜ ==========

  function ensureGroupOrderForTask(taskId) {
    const groups = groupsForTask(taskId);
    if (!groups.length) return;
    let needUpdate = false;

    groups.sort((a, b) => {
      const ai = (typeof a.display_index === "number") ? a.display_index : Infinity;
      const bi = (typeof b.display_index === "number") ? b.display_index : Infinity;
      if (ai !== bi) return ai - bi;
      return (a.name || "").localeCompare(b.name || "", "zh-CN");
    });

    groups.forEach((g, idx) => {
      if (typeof g.display_index !== "number" || g.display_index !== idx) {
        g.display_index = idx;
        needUpdate = true;
      }
    });

    if (needUpdate) {
      scheduleSaveState();
    }
  }

  function reorderGroupsWithinTask(taskId, fromGroupId, toGroupId, insertBefore) {
    let groups = groupsForTask(taskId)
      .slice()
      .sort((a, b) => {
        const ai = (typeof a.display_index === "number") ? a.display_index : 0;
        const bi = (typeof b.display_index === "number") ? b.display_index : 0;
        return ai - bi;
      });

    const fromIndex = groups.findIndex(g => g.id === fromGroupId);
    const toIndex   = groups.findIndex(g => g.id === toGroupId);
    if (fromIndex === -1 || toIndex === -1) return;

    const [moved] = groups.splice(fromIndex, 1);
    let targetIndex = insertBefore ? toIndex : toIndex + (fromIndex < toIndex ? 0 : 1);
    if (targetIndex < 0) targetIndex = 0;
    if (targetIndex > groups.length) targetIndex = groups.length;
    groups.splice(targetIndex, 0, moved);

    groups.forEach((g, idx) => {
      const obj = appState.file_groups[g.id];
      if (obj) obj.display_index = idx;
    });

    scheduleSaveState();
  }

  // ========== Êìç‰ΩúÂ∫èÂàóÈ°∫Â∫èÁÆ°ÁêÜ ==========

  function ensureSequenceOrderForTask(taskId) {
    const seqs = sequenceNodesForTask(taskId);
    if (!seqs.length) return;
    let needUpdate = false;

    seqs.sort((a, b) => {
      const ai = (typeof a.display_index === "number") ? a.display_index : Infinity;
      const bi = (typeof b.display_index === "number") ? b.display_index : Infinity;
      if (ai !== bi) return ai - bi;
      return (a.name || "").localeCompare(b.name || "", "zh-CN");
    });

    seqs.forEach((seq, idx) => {
      if (typeof seq.display_index !== "number" || seq.display_index !== idx) {
        seq.display_index = idx;
        needUpdate = true;
      }
    });

    if (needUpdate) {
      scheduleSaveState();
    }
  }

  function reorderSequencesWithinTask(taskId, fromSeqId, toSeqId, insertBefore) {
    const seqs = sequenceNodesForTask(taskId)
      .slice()
      .sort((a, b) => {
        const ai = (typeof a.display_index === "number") ? a.display_index : 0;
        const bi = (typeof b.display_index === "number") ? b.display_index : 0;
        return ai - bi;
      });

    const fromIndex = seqs.findIndex(s => s.id === fromSeqId);
    const toIndex   = seqs.findIndex(s => s.id === toSeqId);
    if (fromIndex === -1 || toIndex === -1) return;

    const [moved] = seqs.splice(fromIndex, 1);
    let targetIndex = insertBefore ? toIndex : toIndex + (fromIndex < toIndex ? 0 : 1);
    if (targetIndex < 0) targetIndex = 0;
    if (targetIndex > seqs.length) targetIndex = seqs.length;
    seqs.splice(targetIndex, 0, moved);

    seqs.forEach((s, idx) => {
      const obj = appState.operation_sequences[s.id];
      if (obj) obj.display_index = idx;
    });

    scheduleSaveState();
  }

  // ===========
  // ËøúÁ®ã‰∫§‰∫í
  // ===========

  async function loadStateFromServer() {
    try {
      const res = await fetch("/api/state");
      if (!res.ok) throw new Error("Âä†ËΩΩÁä∂ÊÄÅÂ§±Ë¥•");
      const data = await res.json();
      appState = data || { directories: {}, tasks: {}, file_groups: {}, operation_sequences: {} };
      
      // ‚úÖ version ÂÖúÂ∫ï‰∏∫Êï∞Â≠ó
      currentVersion = Number(appState.version ?? data?.version ?? 0) || 0;
      stateLoaded = true;
      // Êï∞ÊçÆÁªìÊûÑÂÖúÂ∫ï
      if (!appState.directories) appState.directories = {};
      if (!appState.tasks) appState.tasks = {};
      if (!appState.file_groups) appState.file_groups = {};
      if (!appState.operation_sequences) appState.operation_sequences = {};

      // ÂàùÂßãÂåñÊ†πÁõÆÂΩï
      if (Object.keys(appState.directories).length === 0) {
        const rootId = "root";
        appState.directories = {
          [rootId]: { id: rootId, name: "Ê†πÁõÆÂΩï", parent_id: null, collapsed: false }
        };
      }

      // ÁªôÊâÄÊúâ‰ªªÂä°ÂÖúÂ∫ï vars Â≠óÊÆµ
      for (const taskId in appState.tasks) {
        const t = appState.tasks[taskId];
        if (!t.vars || typeof t.vars !== "object") {
          t.vars = {};
        }
      }

      // ËäÇÁÇπÂ≠óÊÆµÂÖúÂ∫ïÔºöresult_save_path + executed + parent_id
      for (const seqId in appState.operation_sequences) {
        const seq = appState.operation_sequences[seqId];
        if (!Array.isArray(seq.nodes)) {
          seq.nodes = [];
        }
        seq.nodes.forEach((n, index) => {
          if (typeof n.executed !== "boolean") {
            n.executed = false;
          }
          if (n.node_type === "op" && typeof n.result_save_path !== "string") {
            n.result_save_path = "";
          }
          if (n.node_type === "root" && typeof n.result_save_path === "undefined") {
            n.result_save_path = null; // root Ê≤°ÊúâË∑ØÂæÑÔºå‰ªÖ‰øùÊåÅÂ≠óÊÆµÂ≠òÂú®
          }
          // Êñ∞Â¢ûÔºöËÄÅÊï∞ÊçÆËá™Âä®Ë°• parent_idÔºåÈªòËÆ§ÊàêÁ∫øÊÄßÈìæ
          if (typeof n.parent_id === "undefined") {
            n.parent_id = index === 0 ? null : (seq.nodes[index - 1] ? seq.nodes[index - 1].id : null);
          }
        });
      }

      if (uiState.currentTaskId && !appState.tasks[uiState.currentTaskId]) {
        uiState.currentTaskId = null;
      }

      if (!uiState.currentTaskId) {
        const firstTask = Object.values(appState.tasks)[0];
        if (firstTask) uiState.currentTaskId = firstTask.id;
      }
      
      normalizeTreeDisplayIndex();
      renderAll();
      initHistoryWithCurrentState(); // Êää‚ÄúÂàö‰ªéÂêéÁ´ØÂä†ËΩΩÁöÑÁä∂ÊÄÅ‚Äù‰Ωú‰∏∫ÂéÜÂè≤Á¨¨ 0 Ê≠•
    } catch (e) {
      console.error(e);
      showMessage("‰ªéÂêéÁ´ØÂä†ËΩΩÁä∂ÊÄÅÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÊúçÂä°ÊòØÂê¶ËøêË°å„ÄÇ");
    }
  }

  let saveTimer = null;
  /**
   * scheduleSaveState(skipHistory = false)
   * - ÈªòËÆ§‰ºöÂÖàËÆ∞ÂΩï‰∏ÄÊù°ÂéÜÂè≤Âø´ÁÖßÔºåÂÜçÂú® 500ms Âêé‰øùÂ≠òÂà∞ÂêéÁ´Ø
   * - Êí§ÈîÄ/ÈáçÂÅö„ÄÅÊâßË°åÁä∂ÊÄÅÂà∑Êñ∞Á≠âÂú∫ÊôØÂèØ‰ª•‰º† trueÔºåË°®Á§∫Âè™‰øùÂ≠òÔºå‰∏çËÆ∞ÂéÜÂè≤
   */
  function scheduleSaveState(skipHistory) {
    if (!stateLoaded) {
      // ‚úÖ Ê≤°Âä†ËΩΩÂÆåÊó∂Ôºå‰∏çË¶ÅËß¶Âèë‰øùÂ≠òÔºàÂê¶ÂàôÂæàÂÆπÊòì version Êú™ÂàùÂßãÂåñ/ÊóßÁä∂ÊÄÅË¶ÜÁõñÊñ∞Áä∂ÊÄÅÔºâ
      return;
    }
    if (!skipHistory) {
      recordHistorySnapshot();
    }
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(saveStateToServer, 500);
  }

  async function saveStateToServer() {
    if (!stateLoaded) return;

    // ‚úÖ ‰∏≤Ë°åÂåñÔºöÂ¶ÇÊûúÊ≠£Âú®‰øùÂ≠òÔºåÂ∞±Ê†áËÆ∞ pendingÔºåÁ≠âÊú¨Ê¨°ÁªìÊùüÂêéÂÜçË°•‰∏ÄÊ¨°
    if (saveInFlight) {
      savePending = true;
      return;
    }
    saveInFlight = true;
    try {
      appState.version = currentVersion;
      const res = await fetch("/api/state", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(appState),
      });
      if (!res.ok) {
        // ‚úÖ ÈáçÁÇπÔºöÊääÁâàÊú¨ÂÜ≤Á™ÅÂçïÁã¨ÊãéÂá∫Êù•ÊèêÁ§∫ÔºàÊåâ‰Ω†ÂêéÁ´ØÂÆûÁé∞ÔºåÂèØËÉΩÊòØ 409/412Ôºâ
        if (res.status === 409 || res.status === 412) {
          showMessage("‰øùÂ≠òÂ§±Ë¥•ÔºöÁâàÊú¨ÂÜ≤Á™ÅÔºàÂèØËÉΩÂè¶‰∏Ä‰∏™È°µÈù¢/ÂÆû‰æãÂ∑≤‰øùÂ≠òÔºâ„ÄÇËØ∑ÁÇπÂáª‚ÄúÈáçÊñ∞Âä†ËΩΩ‚ÄùÂêéÂÜçËØï„ÄÇ");
          savePending = false; // ÈÅøÂÖçË°•ÂàÄÁªßÁª≠Êíû
        } else {
          showMessage("‰øùÂ≠òÁä∂ÊÄÅÂà∞ÂêéÁ´ØÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúÊàñÂêéÁ´ØÊó•Âøó„ÄÇHTTP=" + res.status);
        }
        return; // ‚úÖ ‰∏ç throwÔºåÈÅøÂÖç catch ÂÜçÂºπ‰∏ÄÊ¨°
      }
      let resp = null;
      try { resp = await res.json(); } catch (_) {}
      if (resp) {
        const newV = Number(resp.version ?? resp?.state?.version);
        if (!Number.isNaN(newV) && newV >= 0) currentVersion = newV;

        // ÂèØÈÄâÔºöÂ¶ÇÊûúÂêéÁ´ØÂõû‰º†ÁöÑÊòØ‚ÄúÊúÄÁªàÂÜôÂÖ•ÁöÑ state‚ÄùÔºå‰Ω†‰πüÂèØ‰ª•Áî®ÂÆÉË¶ÜÁõñÊú¨Âú∞ÔºåÈÅøÂÖçÂêéÁ´ØÂÅö‰∫ÜËßÑËåÉÂåñÂØºËá¥Â∑ÆÂºÇ
        // if (resp.directories && resp.tasks) appState = resp;
      } else {
        // ÂÖúÂ∫ïÔºöÂ¶ÇÊûúÂêéÁ´Ø‰∏çÂõû JSONÔºå‰ΩÜÁ°ÆÂÆûÊØèÊ¨° save ÈÉΩ‰ºö version+1ÔºåÈÇ£Ëá≥Â∞ëÂâçÁ´ØËá™Â∑± +1
        // ‚ö†Ô∏è Âè™Êúâ‰Ω†Á°ÆÂÆöÂêéÁ´ØÊòØËøôÁßçÁ≠ñÁï•ÊâçÊâìÂºÄÔºåÂê¶ÂàôÂà´Áî®
        // currentVersion += 1;
      }
      console.log("Áä∂ÊÄÅÂ∑≤‰øùÂ≠ò version=", currentVersion);
    } catch (e) {
      console.error(e);
      showMessage("‰øùÂ≠òÁä∂ÊÄÅÂà∞ÂêéÁ´ØÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúÊàñÂêéÁ´ØÊó•Âøó„ÄÇ");
    } finally {
      saveInFlight = false;
      if (savePending) {
        savePending = false;
        // ‚úÖ ÁªìÊùüÂêéÂ¶ÇÊûúÊúüÈó¥ÂèàÊîπÂä®ËøáÔºåÂÜç‰øùÂ≠ò‰∏ÄÊ¨°Ôºà‰∏ç‰ºöÂπ∂ÂèëÔºâ
        saveStateToServer();
      }
    }
  }

  async function requestFileStructure(path) {
    const res = await fetch("/api/file_structure", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ path }),
    });
    const data = await res.json();
    if (!data.success) {
      showMessage("Ëß£ÊûêÂ≠óÊÆµÁªìÊûÑÂ§±Ë¥•Ôºö" + (data.error || "Êú™Áü•ÈîôËØØ"));
      return null;
    }
    return data.structure;
  }

  async function requestFileInfo(path) {
    const res = await fetch("/api/file_info", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ path }),
    });
    const data = await res.json();
    if (!data.success) {
      showMessage("Ëé∑ÂèñÊñá‰ª∂Ë∑ØÂæÑ‰ø°ÊÅØÂ§±Ë¥•Ôºö" + (data.error || "Êú™Áü•ÈîôËØØ"));
      return null;
    }
    return { file_count: data.file_count, total_lines: data.total_lines };
  }

  async function requestHeadTail(path) {
    const res = await fetch("/api/file_head_tail", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ path }),
    });
    const data = await res.json();
    if (!data.success) {
      showMessage("Ëé∑ÂèñÈ¶ñÂ∞æË°åÂ§±Ë¥•Ôºö" + (data.error || "Êú™Áü•ÈîôËØØ"));
      return null;
    }
    return { first: data.first_line, last: data.last_line };
  }

  async function requestGenerateCode(taskId, seqId) {
    const res = await fetch("/api/generate_code", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ task_id: taskId, sequence_id: seqId }),
    });
    const data = await res.json();
    // showMessage(data.message || "generate_code Ë∞ÉÁî®ÂÆåÊàê„ÄÇ");
  }

  async function requestRunSequence(taskId, seqId) {
    const res = await fetch("/api/run_sequence", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ task_id: taskId, sequence_id: seqId }),
    });
    const data = await res.json();

    if (res.ok) {
      const seq = appState.operation_sequences[seqId];
      if (seq && Array.isArray(seq.nodes)) {
        // ÁÆÄÂçïÁ≠ñÁï•ÔºöÂÖ®Ê†á trueÔºà‰Ω†‰πüÂèØ‰ª•ÊéíÈô§ frozenÔºâ
        seq.nodes.forEach(n => { n.executed = true; });
        scheduleSaveState(true); // ÊâßË°åÁªìÊûúÂêåÊ≠•Ôºö‰∏ÄËà¨‰∏çËøõÊí§ÈîÄÊ†à
      }
    }

    showMessage(data.message || "run_sequence Ë∞ÉÁî®ÂÆåÊàê„ÄÇ");
    renderOperationArea();
    applyExecutionStyles();
  }

  function applyExecutionStyles() {
    const nodeEls = document.querySelectorAll(".sequence-node");
    nodeEls.forEach(el => {
      const seqId = el.dataset.sequenceId;
      const nodeId = el.dataset.nodeId;
      const seq = appState.operation_sequences[seqId];
      if (!seq || !Array.isArray(seq.nodes)) return;
      const node = seq.nodes.find(n => n.id === nodeId);
      if (!node) return;

      if (node.executed) {
        el.classList.add("executed");
      } else {
        el.classList.remove("executed");
      }
    });
  }

  // ===========
  // Ê∏≤ÊüìÔºö‰ªªÂä°Ê†ë
  // ===========
  // ========== ÁõÆÂΩï & ‰ªªÂä°È°∫Â∫èÁÆ°ÁêÜÔºà‰ªªÂä°Ê†ëÔºâ ==========

  let draggingTreeItem = null;

  // ÂèñÊüê‰∏™ parentId ‰∏ãÁöÑ‚ÄúÁõÆÂΩï+‰ªªÂä°‚ÄùÂêåÁ∫ßÂàóË°®ÔºàÂÖ±Áî® display_indexÔºâ
  function getTreeChildrenForParent(parentId) {
    const out = [];
    const dirs = appState.directories || {};
    const tasks = appState.tasks || {};

    for (const dirId in dirs) {
      if (dirId === "root") continue;
      const d = dirs[dirId];
      const pid = d.parent_id || "root";
      if (pid === parentId) out.push({ type: "dir", obj: d });
    }
    for (const taskId in tasks) {
      const t = tasks[taskId];
      const pid = t.directory_id || "root";
      if (pid === parentId) out.push({ type: "task", obj: t });
    }
    return out;
  }

  function sortTreeChildren(arr) {
    arr.sort((a, b) => {
      const ai = (typeof a.obj.display_index === "number") ? a.obj.display_index : Infinity;
      const bi = (typeof b.obj.display_index === "number") ? b.obj.display_index : Infinity;
      if (ai !== bi) return ai - bi;

      // ÂÖúÂ∫ïÔºöÂêå index Êó∂ÔºåÁõÆÂΩï‰ºòÂÖàÔºåÁÑ∂ÂêéÊåâÂêçÁß∞
      if (a.type !== b.type) return a.type === "dir" ? -1 : 1;
      return (a.obj.name || "").localeCompare((b.obj.name || ""), "zh-CN");
    });
    return arr;
  }

  // Áªü‰∏ÄÁªôÊâÄÊúâ parent ÁöÑÂ≠êÈ°πË°•ÈΩê display_indexÔºàËÄÅÊï∞ÊçÆÂÖºÂÆπÔºâ
  function normalizeTreeDisplayIndex() {
    const parentIds = new Set(["root"]);

    // Êî∂ÈõÜÂèØËÉΩÂá∫Áé∞ÁöÑ parentId
    for (const dirId in (appState.directories || {})) {
      if (dirId === "root") continue;
      const d = appState.directories[dirId];
      parentIds.add(d.parent_id || "root");
      parentIds.add(dirId);
    }
    for (const taskId in (appState.tasks || {})) {
      const t = appState.tasks[taskId];
      parentIds.add(t.directory_id || "root");
    }

    let changed = false;

    parentIds.forEach(pid => {
      const children = getTreeChildrenForParent(pid);
      if (!children.length) return;

      sortTreeChildren(children);
      children.forEach((it, idx) => {
        if (typeof it.obj.display_index !== "number" || it.obj.display_index !== idx) {
          it.obj.display_index = idx;
          changed = true;
        }
      });
    });

    if (changed) {
      scheduleSaveState(true); // Âè™ÂêåÊ≠•Ôºå‰∏çËÆ∞ÂéÜÂè≤ÔºàÈÅøÂÖç‚ÄúÂä†ËΩΩÂ∞±Â§ö‰∏ÄÊ≠•Êí§ÈîÄ‚ÄùÔºâ
    }
  }

  function getMaxTreeDisplayIndex(parentId) {
    const children = getTreeChildrenForParent(parentId);
    let max = -1;
    children.forEach(it => {
      const v = (typeof it.obj.display_index === "number") ? it.obj.display_index : -1;
      if (v > max) max = v;
    });
    return max;
  }

  function reorderTreeItemsWithinParent(parentId, from, to, insertBefore) {
    const siblings = getTreeChildrenForParent(parentId);
    if (siblings.length <= 1) return;

    sortTreeChildren(siblings);

    const fromIndex = siblings.findIndex(x => x.type === from.type && x.obj.id === from.id);
    const toIndex = siblings.findIndex(x => x.type === to.type && x.obj.id === to.id);
    if (fromIndex === -1 || toIndex === -1) return;

    const [moved] = siblings.splice(fromIndex, 1);
    let targetIndex = insertBefore ? toIndex : toIndex + (fromIndex < toIndex ? 0 : 1);
    if (targetIndex < 0) targetIndex = 0;
    if (targetIndex > siblings.length) targetIndex = siblings.length;
    siblings.splice(targetIndex, 0, moved);

    siblings.forEach((it, idx) => {
      it.obj.display_index = idx;
    });

    scheduleSaveState(); // ËøôÂ±û‰∫éÁî®Êà∑Êìç‰ΩúÔºöË¶ÅËøõÂÖ•Êí§ÈîÄÊ†à
  }

  function renderTaskTree() {
    const container = document.getElementById("task-tree");
    container.innerHTML = "";

    const directories = appState.directories || {};
    const tasks = appState.tasks || {};

    const childrenMap = {};
    function addChild(parentId, item) {
      if (!childrenMap[parentId]) childrenMap[parentId] = [];
      childrenMap[parentId].push(item);
    }

    for (const dirId in directories) {
      const dir = directories[dirId];
      const pid = dir.parent_id || "root";
      if (dirId === "root") continue;
      addChild(pid, { type: "dir", obj: dir });
    }

    for (const taskId in tasks) {
      const task = tasks[taskId];
      const pid = task.directory_id || "root";
      addChild(pid, { type: "task", obj: task });
    }

    function renderChildren(parentId, level, parentEl) {
      const children = childrenMap[parentId] || [];
      // children.sort((a, b) => {
      //   if (a.type === b.type) {
      //     return a.obj.name.localeCompare(b.obj.name, "zh-CN");
      //   }
      //   return a.type === "dir" ? -1 : 1;
      // });
      sortTreeChildren(children);

      children.forEach(item => {
        if (item.type === "dir") {
          const dir = item.obj;
          const row = document.createElement("div");
          row.className = "tree-row";
          row.style.paddingLeft = (4 + level * 16) + "px";
          row.dataset.nodeType = "directory";
          row.dataset.id = dir.id;

          row.setAttribute("draggable", "true");
          row.dataset.parentId = parentId;

          row.addEventListener("dragstart", (e) => {
            draggingTreeItem = { type: "dir", id: dir.id, parentId };
            e.dataTransfer.effectAllowed = "move";
            e.dataTransfer.setData("text/plain", dir.id);
            row.classList.add("dragging");
          });

          row.addEventListener("dragend", () => {
            draggingTreeItem = null;
            document
              .querySelectorAll(".tree-row.drag-over-top, .tree-row.drag-over-bottom, .tree-row.dragging")
              .forEach(el => el.classList.remove("drag-over-top", "drag-over-bottom", "dragging"));
          });

          row.addEventListener("dragover", (e) => {
            if (!draggingTreeItem) return;
            if (draggingTreeItem.parentId !== parentId) return; // Âè™ÂÖÅËÆ∏ÂêåÁ∫ßÊéíÂ∫è
            if (draggingTreeItem.type === "dir" && draggingTreeItem.id === dir.id) return;

            e.preventDefault();
            const rect = row.getBoundingClientRect();
            const isTopHalf = (e.clientY - rect.top) < rect.height / 2;
            row.classList.toggle("drag-over-top", isTopHalf);
            row.classList.toggle("drag-over-bottom", !isTopHalf);
          });

          row.addEventListener("dragleave", () => {
            row.classList.remove("drag-over-top", "drag-over-bottom");
          });

          row.addEventListener("drop", (e) => {
            if (!draggingTreeItem) return;
            if (draggingTreeItem.parentId !== parentId) return;

            e.preventDefault();
            const rect = row.getBoundingClientRect();
            const isTopHalf = (e.clientY - rect.top) < rect.height / 2;

            reorderTreeItemsWithinParent(
              parentId,
              draggingTreeItem,
              { type: "dir", id: dir.id },
              isTopHalf
            );

            draggingTreeItem = null;
            renderTaskTree();
          });

          const arrow = document.createElement("span");
          arrow.className = "tree-arrow";
          arrow.textContent = dir.collapsed ? "‚ñ∂" : "‚ñº";
          arrow.addEventListener("click", e => {
            e.stopPropagation();
            dir.collapsed = !dir.collapsed;
            scheduleSaveState();
            renderTaskTree();
          });
          row.appendChild(arrow);

          const name = document.createElement("span");
          name.className = "tree-name";
          name.textContent = dir.name || "(Êú™ÂëΩÂêçÁõÆÂΩï)";
          row.appendChild(name);

          parentEl.appendChild(row);

          if (!dir.collapsed) {
            renderChildren(dir.id, level + 1, parentEl);
          }
        } else {
          const task = item.obj;
          const row = document.createElement("div");
          row.className = "tree-row task-row";
          row.style.paddingLeft = (4 + level * 16) + "px";
          row.dataset.nodeType = "task";
          row.dataset.id = task.id;
          row.setAttribute("draggable", "true");
          row.dataset.parentId = parentId;

          row.addEventListener("dragstart", (e) => {
            draggingTreeItem = { type: "task", id: task.id, parentId };
            e.dataTransfer.effectAllowed = "move";
            e.dataTransfer.setData("text/plain", task.id);
            row.classList.add("dragging");
          });

          row.addEventListener("dragend", () => {
            draggingTreeItem = null;
            document
              .querySelectorAll(".tree-row.drag-over-top, .tree-row.drag-over-bottom, .tree-row.dragging")
              .forEach(el => el.classList.remove("drag-over-top", "drag-over-bottom", "dragging"));
          });

          row.addEventListener("dragover", (e) => {
            if (!draggingTreeItem) return;
            if (draggingTreeItem.parentId !== parentId) return;
            if (draggingTreeItem.type === "task" && draggingTreeItem.id === task.id) return;

            e.preventDefault();
            const rect = row.getBoundingClientRect();
            const isTopHalf = (e.clientY - rect.top) < rect.height / 2;
            row.classList.toggle("drag-over-top", isTopHalf);
            row.classList.toggle("drag-over-bottom", !isTopHalf);
          });

          row.addEventListener("dragleave", () => {
            row.classList.remove("drag-over-top", "drag-over-bottom");
          });

          row.addEventListener("drop", (e) => {
            if (!draggingTreeItem) return;
            if (draggingTreeItem.parentId !== parentId) return;

            e.preventDefault();
            const rect = row.getBoundingClientRect();
            const isTopHalf = (e.clientY - rect.top) < rect.height / 2;

            reorderTreeItemsWithinParent(
              parentId,
              draggingTreeItem,
              { type: "task", id: task.id },
              isTopHalf
            );

            draggingTreeItem = null;
            renderTaskTree();
          });

          if (uiState.currentTaskId === task.id) {
            row.classList.add("active");
          }

          const arrow = document.createElement("span");
          arrow.className = "tree-arrow placeholder";
          row.appendChild(arrow);

          const name = document.createElement("span");
          name.className = "tree-name";
          name.textContent = task.name || "(Êú™ÂëΩÂêç‰ªªÂä°)";
          row.appendChild(name);

          row.addEventListener("click", () => {
            uiState.currentTaskId = task.id;
            uiState.selectedFilePathId = null;
            uiState.fieldStructure = null;
            renderAll();
          });

          parentEl.appendChild(row);
        }
      });
    }

    renderChildren("root", 0, container);

    if (!Object.keys(appState.tasks || {}).length) {
      const hint = document.createElement("div");
      hint.className = "hint";
      hint.textContent = "Âè≥ÈîÆÁ©∫ÁôΩÂ§ÑÂàõÂª∫ÁõÆÂΩïÔºåÂÜçÂú®ÁõÆÂΩï‰∏äÂè≥ÈîÆÂàõÂª∫‰ªªÂä°„ÄÇ";
      container.appendChild(hint);
    }
  }

  // ===========
  // Ê∏≤ÊüìÔºöÊñá‰ª∂ÁªÑ & Êñá‰ª∂Ë∑ØÂæÑÔºàÂê´ÊãñÊãΩÊéíÂ∫èÔºâ
  // ===========

  let draggingGroupId = null;

  function renderFileGroups() {
    const container = document.getElementById("file-groups");
    container.innerHTML = "";

    const task = getCurrentTask();
    if (!task) {
      const hint = document.createElement("div");
      hint.className = "hint";
      hint.textContent = "ËØ∑ÂÖàÂú®Â∑¶‰æßÈÄâÊã©‰∏Ä‰∏™‰ªªÂä°„ÄÇ";
      container.appendChild(hint);
      return;
    }

    let groups = groupsForTask(task.id);
    if (!groups.length) {
      const hint = document.createElement("div");
      hint.className = "hint";
      hint.textContent = "Âè≥ÈîÆÁ©∫ÁôΩÂå∫ÂüüÂàõÂª∫Êñá‰ª∂ÁªÑ„ÄÇ";
      container.appendChild(hint);
      return;
    }

    // Á°Æ‰øùÊúâÂ±ïÁ§∫È°∫Â∫è
    ensureGroupOrderForTask(task.id);

    // Êåâ display_index ÊéíÂ∫è
    groups = groups.slice().sort((a, b) => {
      const ai = (typeof a.display_index === "number") ? a.display_index : 0;
      const bi = (typeof b.display_index === "number") ? b.display_index : 0;
      return ai - bi;
    });

    groups.forEach(group => {
      const groupDiv = document.createElement("div");
      groupDiv.className = "file-group";
      groupDiv.dataset.groupId = group.id;

      // ÂêØÁî®ÊãñÊãΩ
      groupDiv.setAttribute("draggable", "true");

      groupDiv.addEventListener("dragstart", (e) => {
        draggingGroupId = group.id;
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", group.id);
        groupDiv.classList.add("dragging");
      });

      groupDiv.addEventListener("dragend", () => {
        draggingGroupId = null;
        document
          .querySelectorAll(".file-group.drag-over-top, .file-group.drag-over-bottom, .file-group.dragging")
          .forEach(el => el.classList.remove("drag-over-top", "drag-over-bottom", "dragging"));
      });

      groupDiv.addEventListener("dragover", (e) => {
        if (!draggingGroupId || draggingGroupId === group.id) return;
        e.preventDefault();
        const rect = groupDiv.getBoundingClientRect();
        const offsetY = e.clientY - rect.top;
        const isTopHalf = offsetY < rect.height / 2;
        groupDiv.classList.toggle("drag-over-top", isTopHalf);
        groupDiv.classList.toggle("drag-over-bottom", !isTopHalf);
      });

      groupDiv.addEventListener("dragleave", () => {
        groupDiv.classList.remove("drag-over-top", "drag-over-bottom");
      });

      groupDiv.addEventListener("drop", (e) => {
        if (!draggingGroupId || draggingGroupId === group.id) return;
        e.preventDefault();
        const rect = groupDiv.getBoundingClientRect();
        const offsetY = e.clientY - rect.top;
        const isTopHalf = offsetY < rect.height / 2;

        reorderGroupsWithinTask(task.id, draggingGroupId, group.id, isTopHalf);
        draggingGroupId = null;
        renderFileGroups();
      });

      const header = document.createElement("div");
      header.className = "file-group-header";

      const arrow = document.createElement("span");
      arrow.className = "tree-arrow";
      arrow.textContent = group.collapsed ? "‚ñ∂" : "‚ñº";
      header.appendChild(arrow);

      const title = document.createElement("div");
      title.className = "file-group-title";
      title.textContent = group.name;
      header.appendChild(title);

      header.addEventListener("click", () => {
        group.collapsed = !group.collapsed;
        scheduleSaveState();
        renderFileGroups();
      });

      groupDiv.appendChild(header);

      const body = document.createElement("div");
      body.className = "file-group-body";
      body.style.display = group.collapsed ? "none" : "block";

      (group.file_paths || []).forEach(fp => {
        const row = document.createElement("div");
        row.className = "file-path-row";
        row.dataset.filePathId = fp.id;
        if (uiState.selectedFilePathId === fp.id) {
          row.classList.add("active");
        }

        const main = document.createElement("div");
        main.className = "file-path-main";

        const textSpan = document.createElement("span");
        textSpan.className = "file-path-text";
        textSpan.textContent = fp.path;
        main.appendChild(textSpan);

        if (fp.info) {
          const infoSpan = document.createElement("span");
          infoSpan.className = "file-path-info";
          infoSpan.textContent = `Êñá‰ª∂Êï∞: ${fp.info.file_count}, ÊÄªË°åÊï∞: ${fp.info.total_lines}`;
          main.appendChild(infoSpan);
        }

        row.appendChild(main);

        row.addEventListener("click", async () => {
          uiState.selectedFilePathId = fp.id;
          renderFileGroups();

          const taskId = group.task_id;
          const resolvedPath = resolveTaskVarsInString(fp.path, taskId);

          const struct = await requestFileStructure(resolvedPath);
          if (struct) {
            uiState.fieldStructure = { struct, path: resolvedPath };
            renderFieldStructure();
          }
        });

        body.appendChild(row);
      });

      groupDiv.appendChild(body);
      container.appendChild(groupDiv);
    });
  }

  // ===========
  // Ê∏≤ÊüìÔºöÂ≠óÊÆµÁªìÊûÑ
  // ===========

  function renderFieldStructure() {
    const container = document.getElementById("field-structure");
    container.innerHTML = "";

    if (!uiState.fieldStructure) {
      const div = document.createElement("div");
      div.className = "field-structure-empty";
      div.textContent = "ËØ∑Âú®Á¨¨‰∫åÊ†èÁÇπÂáªÊüê‰∏™Êñá‰ª∂Ë∑ØÂæÑÔºåÂ±ïÁ§∫ÂÖ∂Á¨¨‰∏ÄË°åÊï∞ÊçÆÁöÑÁªìÊûÑ„ÄÇ";
      container.appendChild(div);
      return;
    }

    const struct = uiState.fieldStructure.struct;

    const rootRow = document.createElement("div");
    rootRow.className = "field-row";

    const toggle = document.createElement("span");
    toggle.className = "field-toggle";
    toggle.textContent = "‚ñº";
    rootRow.appendChild(toggle);

    const rootName = document.createElement("span");
    rootName.className = "field-name";
    rootName.dataset.path = ".";
    rootName.textContent = ".";
    rootRow.appendChild(rootName);

    const typeSpan = document.createElement("span");
    typeSpan.className = "field-type";
    typeSpan.textContent = "[root]";
    rootRow.appendChild(typeSpan);

    container.appendChild(rootRow);

    const childrenContainer = document.createElement("div");
    childrenContainer.className = "field-children";
    container.appendChild(childrenContainer);

    toggle.addEventListener("click", () => {
      const hidden = childrenContainer.style.display === "none";
      childrenContainer.style.display = hidden ? "block" : "none";
      toggle.textContent = hidden ? "‚ñº" : "‚ñ∂";
    });

    function renderNode(node, parentPath, parentEl, listContext) {
      if (!node) return;
      const type = node.type;
      if (type === "dict") {
        const children = node.children || {};
        Object.keys(children).forEach(key => {
          const childNode = children[key];
          const pathPrefix = parentPath || ".";
          const path = pathPrefix === "."
            ? "." + key + (childNode.type === "list" ? "[]" : "")
            : parentPath + "." + key + (childNode.type === "list" ? "[]" : "");

          const row = document.createElement("div");
          row.className = "field-row";

          const hasChildren = childNode.type === "dict" || childNode.type === "list";
          const toggle = document.createElement("span");
          toggle.className = "field-toggle";
          if (!hasChildren) {
            toggle.classList.add("empty");
            toggle.textContent = "";
          } else {
            toggle.textContent = "‚ñº";
          }
          row.appendChild(toggle);

          const nameSpan = document.createElement("span");
          nameSpan.className = "field-name";
          nameSpan.dataset.path = path;
          nameSpan.textContent = key + (childNode.type === "list" ? "[]" : "");
          row.appendChild(nameSpan);

          const typeSpan = document.createElement("span");
          typeSpan.className = "field-type";
          if (childNode.type === "dict") {
            typeSpan.textContent = "[dict]";
          } else if (childNode.type === "list") {
            typeSpan.textContent = "[list]";
          } else {
            typeSpan.textContent = "[" + (childNode.value_type || "value") + "]";
          }
          row.appendChild(typeSpan);

          parentEl.appendChild(row);

          let childrenWrapper = null;
          if (hasChildren) {
            childrenWrapper = document.createElement("div");
            childrenWrapper.className = "field-children";
            parentEl.appendChild(childrenWrapper);

            toggle.addEventListener("click", () => {
              const hidden = childrenWrapper.style.display === "none";
              childrenWrapper.style.display = hidden ? "block" : "none";
              toggle.textContent = hidden ? "‚ñº" : "‚ñ∂";
            });
          }

          if (childNode.type === "dict") {
            renderNode(childNode, path, childrenWrapper, false);
          } else if (childNode.type === "list") {
            renderListItem(childNode, path, childrenWrapper);
          }
        });
      } else if (type === "list") {
        renderListItem(node, parentPath, parentEl);
      }
    }

    function renderListItem(listNode, listPath, parentEl) {
      if (!listNode) return;
      const item = listNode.item || null;
      if (!item) return;

      if (item.type === "dict") {
        renderNode(item, listPath, parentEl, true);
      } else if (item.type === "value") {
        const row = document.createElement("div");
        row.className = "field-row";

        const toggle = document.createElement("span");
        toggle.className = "field-toggle empty";
        toggle.textContent = "";
        row.appendChild(toggle);

        const nameSpan = document.createElement("span");
        nameSpan.className = "field-name";
        nameSpan.dataset.path = listPath;
        nameSpan.textContent = listPath;
        row.appendChild(nameSpan);

        const typeSpan = document.createElement("span");
        typeSpan.className = "field-type";
        typeSpan.textContent = "[" + (item.value_type || "value") + "]";
        row.appendChild(typeSpan);

        parentEl.appendChild(row);
      } else if (item.type === "list") {
        const row = document.createElement("div");
        row.className = "field-row";

        const toggle = document.createElement("span");
        toggle.className = "field-toggle";
        toggle.textContent = "‚ñº";
        row.appendChild(toggle);

        const nameSpan = document.createElement("span");
        nameSpan.className = "field-name";
        nameSpan.dataset.path = listPath + "[]";
        nameSpan.textContent = listPath + "[]";
        row.appendChild(nameSpan);

        const typeSpan = document.createElement("span");
        typeSpan.className = "field-type";
        typeSpan.textContent = "[list]";
        row.appendChild(typeSpan);

        parentEl.appendChild(row);

        const childrenWrapper = document.createElement("div");
        childrenWrapper.className = "field-children";
        parentEl.appendChild(childrenWrapper);

        toggle.addEventListener("click", () => {
          const hidden = childrenWrapper.style.display === "none";
          childrenWrapper.style.display = hidden ? "block" : "none";
          toggle.textContent = hidden ? "‚ñº" : "‚ñ∂";
        });

        renderListItem(item, listPath + "[]", childrenWrapper);
      }
    }

    renderNode(struct, ".", childrenContainer, false);

    container.onclick = function (e) {
      const nameEl = e.target.closest(".field-name");
      if (!nameEl) return;
      const path = nameEl.dataset.path;
      if (!path) return;
      copyToClipboard(path);
      console.log("Â≠óÊÆµË∑ØÂæÑÂ∑≤Â§çÂà∂:", path);
    };
  }

    // ===========
  // Ê∏≤ÊüìÔºöÊìç‰ΩúÂ∫èÂàóÁîªÊùøÔºàÂê´ÊãñÊãΩÊéíÂ∫è + ÊäòÂè† + ÂàÜÊîØÔºâ
  // ===========

  let draggingSequenceId = null;

  // ÊûÑÈÄ†Âçï‰∏™ËäÇÁÇπ DOMÔºàÊ†ëÂΩ¢ÈÄíÂΩí‰∏≠Â§çÁî®Ôºâ
  function createSequenceNodeElement(seq, node) {
    const nodeDiv = document.createElement("div");
    nodeDiv.className = "sequence-node";
    nodeDiv.dataset.nodeType = node.node_type === "root" ? "root-node" : "op-node";
    nodeDiv.dataset.sequenceId = seq.id;
    nodeDiv.dataset.nodeId = node.id;
    if (node.frozen) {
      nodeDiv.classList.add("frozen");
    }
    if (node.node_type === "root") {
      nodeDiv.classList.add("root");
    }
    if (node.executed) {
      nodeDiv.classList.add("executed");
    }

    const main = document.createElement("div");
    main.className = "sequence-node-main";

    const titleSpan = document.createElement("span");
    titleSpan.className = "sequence-node-title";
    titleSpan.textContent = node.name || (node.node_type === "root" ? "Ê†πËäÇÁÇπ" : "Êú™ÂëΩÂêçËäÇÁÇπ");
    main.appendChild(titleSpan);

    const typeSpan = document.createElement("span");
    typeSpan.className = "sequence-node-type";
    if (node.node_type === "root") {
      typeSpan.textContent = "Ê†πËäÇÁÇπÔºàÊñá‰ª∂ÁªÑÂêàÂπ∂Êï∞ÊçÆÔºâ";
    } else {
      typeSpan.textContent = node.function_name ? `ÂáΩÊï∞: ${node.function_name}` : "ÂáΩÊï∞Êú™ËÆæÁΩÆ";
    }
    main.appendChild(typeSpan);

    nodeDiv.appendChild(main);

    // ÁªìÊûúË∑ØÂæÑÂ±ïÁ§∫Ë°åÔºàÂßãÁªàÂàõÂª∫Ôºå‰æø‰∫éËæìÂÖ•Êó∂ÂÆûÊó∂Êõ¥Êñ∞Ôºâ
    let resultPathEl = null;
    if (node.node_type === "op") {
      resultPathEl = document.createElement("div");
      resultPathEl.className = "sequence-node-result-path";
      resultPathEl.dataset.role = "result-save-path";
      resultPathEl.textContent = node.result_save_path || "";
      resultPathEl.style.display = node.result_save_path ? "block" : "none";
      nodeDiv.appendChild(resultPathEl);
    }

    const edit = document.createElement("div");
    edit.className = "sequence-node-edit";

    if (node.node_type === "op") {
      const nameLabel = document.createElement("label");
      nameLabel.textContent = "ËäÇÁÇπÂêçÁß∞Ôºö";
      const nameInput = document.createElement("input");
      nameInput.value = node.name || "";
      nameLabel.appendChild(nameInput);
      edit.appendChild(nameLabel);

      const funcLabel = document.createElement("label");
      funcLabel.textContent = "ÂáΩÊï∞ÂêçÁß∞ÔºàÂèØËæìÂèØÈÄâÔºâÔºö";
      const funcInput = document.createElement("input");
      funcInput.setAttribute("list", "function-names");
      funcInput.value = node.function_name || "";
      funcLabel.appendChild(funcInput);
      edit.appendChild(funcLabel);

      const paramsLabel = document.createElement("label");
      paramsLabel.textContent = "ÂèÇÊï∞ÔºàJSON Â≠óÁ¨¶‰∏≤ÔºâÔºö";

      // --- Êñ∞Â¢ûÔºöÊèíÂÖ•ÂºïÁî®ÊåâÈíÆÊù°Ôºà‰∏çÂº∫Âà∂Áî®ÔºåÁ∫ØËæÖÂä©Ôºâ---
      const refBar = document.createElement("div");
      refBar.style.display = "flex";
      refBar.style.gap = "6px";
      refBar.style.margin = "6px 0 8px 0";
      refBar.style.flexWrap = "wrap";

      const btnInsertGroupRef = document.createElement("button");
      btnInsertGroupRef.type = "button";
      btnInsertGroupRef.textContent = "ÊèíÂÖ•Êñá‰ª∂ÁªÑÂºïÁî®";

      const btnInsertNodeOutRef = document.createElement("button");
      btnInsertNodeOutRef.type = "button";
      btnInsertNodeOutRef.textContent = "ÊèíÂÖ•ËäÇÁÇπËæìÂá∫ÂºïÁî®";

      refBar.appendChild(btnInsertGroupRef);
      refBar.appendChild(btnInsertNodeOutRef);
      // ‚úÖ ÊñπÊ°àAÔºöÈòªÊ≠¢ÊåâÈíÆÊä¢ÁÑ¶ÁÇπÔºåÈÅøÂÖç paramsTextarea blur Ëß¶Âèë JSON Ê†°È™åÂºπÁ™ó
      function preventButtonStealFocus(btn) {
        // Safari/Chrome/Edge Âü∫Êú¨ÈÉΩÊîØÊåÅ pointerdown
        btn.addEventListener("pointerdown", (ev) => {
          ev.preventDefault(); // ‰∏çËÆ©ÊåâÈíÆËé∑ÂæóÁÑ¶ÁÇπ
        });
        // ÂÖúÂ∫ïÔºöÂ∞ëÊï∞ÁéØÂ¢ÉÂè™Êúâ mousedown
        btn.addEventListener("mousedown", (ev) => {
          ev.preventDefault();
        });
      }

      // ÂØπ‰∏â‰∏™ÊåâÈíÆÈÉΩÁîüÊïà
      preventButtonStealFocus(btnInsertGroupRef);
      preventButtonStealFocus(btnInsertNodeOutRef);

      // --- params textarea ---
      const paramsTextarea = document.createElement("textarea");
      paramsTextarea.value = node.params_json || "{}";
      paramsLabel.appendChild(refBar);
      paramsLabel.appendChild(paramsTextarea);
      edit.appendChild(paramsLabel);

      btnInsertGroupRef.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const items = listAllFileGroups();
        const picked = promptPickFromList(
          "ÈÄâÊã©Ë¶ÅÂºïÁî®ÁöÑÊñá‰ª∂ÁªÑ",
          items,
          it => `[${it.task_name}] ${it.name}  (id=${it.id})`
        );
        if (!picked) return;
        const snippet = buildRefSnippet({
          kind: "file_group",
          file_group_id: picked.id,
          file_group_name: picked.name
        });
        insertTextAtCursor(paramsTextarea, snippet);
      });

      btnInsertNodeOutRef.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const items = listAllNodeOutputs();
        const picked = promptPickFromList(
          "ÈÄâÊã©Ë¶ÅÂºïÁî®ÁöÑËäÇÁÇπËæìÂá∫Ôºàresult_save_path ÂøÖÈ°ªÈùûÁ©∫Ôºâ",
          items,
          it => `[${it.task_name}/${it.sequence_name}/${it.node_name}] ${it.result_save_path}  (seq=${it.sequence_id}, node=${it.node_id})`
        );
        if (!picked) return;
        const snippet = buildRefSnippet({
          kind: "node_output",
          sequence_id: picked.sequence_id,
          node_id: picked.node_id,
          node_name: picked.node_name
        });
        insertTextAtCursor(paramsTextarea, snippet);
      });

      const resultLabel = document.createElement("label");
      resultLabel.textContent = "‰øùÂ≠òÁªìÊûúË∑ØÂæÑÔºàÂèØ‰∏∫Á©∫ÔºõÊîØÊåÅ {{var}}ÔºâÔºö";
      const resultInput = document.createElement("input");
      resultInput.value = node.result_save_path || "";
      resultLabel.appendChild(resultInput);
      edit.appendChild(resultLabel);

      const descLabel = document.createElement("label");
      descLabel.textContent = "‰ª£Á†ÅÔºàÂèØÈÄâÔºâÔºö";
      const descTextarea = document.createElement("textarea");
      descTextarea.value = node.description || "";
      descLabel.appendChild(descTextarea);
      edit.appendChild(descLabel);

      function markNeedRerunAndSave(skipHistory) {
        const wasExecuted = !!node.executed; // ÊàñËÄÖÊ£ÄÊü•Â≠êÊ†ëÊòØÂê¶Êúâ true
        if (wasExecuted) {
          setExecutedForNodeAndDescendants(seq, node.id, false);
          applyExecutionStyles();
        }
        scheduleSaveState(!!skipHistory);
      }

      function updateMainTitle() {
        titleSpan.textContent = node.name || (node.node_type === "root" ? "Ê†πËäÇÁÇπ" : "Êú™ÂëΩÂêçËäÇÁÇπ");
      }
      function updateMainType() {
        if (node.node_type === "root") {
          typeSpan.textContent = "Ê†πËäÇÁÇπÔºàÊñá‰ª∂ÁªÑÂêàÂπ∂Êï∞ÊçÆÔºâ";
        } else {
          typeSpan.textContent = node.function_name ? `ÂáΩÊï∞: ${node.function_name}` : "ÂáΩÊï∞Êú™ËÆæÁΩÆ";
        }
      }
      function updateResultPathLine() {
        if (!resultPathEl) return;
        const v = node.result_save_path || "";
        resultPathEl.textContent = v;
        resultPathEl.style.display = v ? "block" : "none";
      }

      // ========== ÂÆûÊó∂ÁªëÂÆöÔºàinputÔºöÂÆûÊó∂‰øùÂ≠ò‰∏çÂÖ•Êí§ÈîÄÔºõblur/changeÔºöÊèê‰∫§ÂÖ•Êí§ÈîÄÔºâ ==========

      // ËäÇÁÇπÂêçÁß∞
      nameInput.addEventListener("input", () => {
        node.name = (nameInput.value || "").trim();
        updateMainTitle();
        markNeedRerunAndSave(true);
      });
      nameInput.addEventListener("blur", () => {
        const v = (nameInput.value || "").trim() || "Êú™ÂëΩÂêçËäÇÁÇπ";
        node.name = v;
        nameInput.value = v; // ‚úÖ
        updateMainTitle();
        markNeedRerunAndSave(false);
      });

      // ÂáΩÊï∞Âêç
      funcInput.addEventListener("input", () => {
        const v = (funcInput.value || "").trim();
        node.function_name = v || null;
        updateMainType();
        markNeedRerunAndSave(true);
      });
      funcInput.addEventListener("blur", () => {
        const v = (funcInput.value || "").trim();
        node.function_name = v || null;
        funcInput.value = v; // ‚úÖ ÂõûÂÜôÂΩí‰∏ÄÂåñÔºàÂéªÊéâÈ¶ñÂ∞æÁ©∫Ê†ºÔºâ
        updateMainType();
        markNeedRerunAndSave(false);
      });

      // ÂèÇÊï∞ JSONÔºöËæìÂÖ•Êó∂‰∏çÂºπÁ™óÔºõblur Êó∂Â¶ÇÊûúÈùûÊ≥ïÁªô‰∏ÄÊ¨°ÊèêÁ§∫Ôºà‰ΩÜ‰ªçÂÖÅËÆ∏‰øùÂ≠òÂ≠óÁ¨¶‰∏≤ÁöÑËØùÂèØÊääÊ†°È™åÂéªÊéâÔºâ
      paramsTextarea.addEventListener("input", () => {
        node.params_json = paramsTextarea.value || "{}";
        markNeedRerunAndSave(true);
      });
      let lastInvalidParamsValue = null;
      paramsTextarea.addEventListener("blur", () => {
        const v = (paramsTextarea.value || "{}").trim() || "{}";

        // ‚úÖ ÂõûÂÜôÊúÄÁªàÂÄºÔºà‰Ω†‰πãÂâç‰πüÊÉ≥Ë¶ÅËøô‰∏™Ë°å‰∏∫Ôºâ
        paramsTextarea.value = v;
        node.params_json = v;

        // ‚úÖ Âè™Âú®‚ÄúÊú¨Ê¨° blur‚ÄùÂÅö‰∏ÄÊ¨°Ê†°È™åÔºõ‰∏îÂêå‰∏Ä‰∏™ÈùûÊ≥ïÂÜÖÂÆπ‰∏çÈáçÂ§çÂºπ
        try {
          JSON.parse(v);
          lastInvalidParamsValue = null; // ÂêàÊ≥ïÂêéÊ∏ÖÁ©∫‚ÄúÂ∑≤ÊèêÈÜí‚ÄùËÆ∞ÂøÜ
        } catch (e) {
          if (lastInvalidParamsValue !== v) {
            lastInvalidParamsValue = v;
            showMessage("ÂèÇÊï∞ÂøÖÈ°ªÊòØÊ†ºÂºèÊ≠£Á°ÆÁöÑ JSON Â≠óÁ¨¶‰∏≤„ÄÇ");
          }
          // ËøôÈáå‰∏ç returnÔºåËÆ©ÂÆÉ‰ªçÁÑ∂ËÉΩ‰øùÂ≠òÂ≠óÁ¨¶‰∏≤ÔºàÁ¨¶Âêà‰Ω†‚ÄúÂÆûÊó∂‰øùÂ≠ò‚ÄùÁöÑËØ≠‰πâÔºâ
        }

        markNeedRerunAndSave(false);
      });

      // ‰øùÂ≠òÁªìÊûúË∑ØÂæÑ
      resultInput.addEventListener("input", () => {
        node.result_save_path = (resultInput.value || "").trim();
        updateResultPathLine();
        markNeedRerunAndSave(true);
      });
      resultInput.addEventListener("blur", () => {
        const v = (resultInput.value || "").trim();
        node.result_save_path = v;     // ÊúÄÁªàÂÖÅËÆ∏Á©∫Â≠óÁ¨¶‰∏≤
        resultInput.value = v;         // ‚úÖ ÂõûÂÜô
        updateResultPathLine();
        markNeedRerunAndSave(false);
      });

      // ‰ª£Á†Å/ÊèèËø∞
      descTextarea.addEventListener("input", () => {
        node.description = descTextarea.value || "";
        markNeedRerunAndSave(true);
      });
      descTextarea.addEventListener("blur", () => {
        const v = (descTextarea.value || "").trim();
        node.description = v;
        descTextarea.value = v; // ‚úÖ ÂõûÂÜô
        markNeedRerunAndSave(false);
      });
    } else {
      const info = document.createElement("div");
      info.textContent = "Ê†πËäÇÁÇπÁî±Êñá‰ª∂ÁªÑËá™Âä®ÁîüÊàêÔºå‰∏çÊîØÊåÅÁºñËæë„ÄÇ";
      edit.appendChild(info);
    }

    nodeDiv.appendChild(edit);

    if (node.node_type === "op") {
      main.addEventListener("click", () => {
        const visible = edit.style.display === "block";
        edit.style.display = visible ? "none" : "block";
        nodeDiv.classList.toggle("highlight", !visible);
      });
    }

    return nodeDiv;
  }

  // Ê†ëÂΩ¢Ê∏≤ÊüìÔºöÂêå‰∏ÄÁà∂ËäÇÁÇπÁöÑÂ≠êËäÇÁÇπÊ®™ÂêëÊéíÂàó
  function renderSequenceTree(seq, container) {
    const nodes = seq.nodes || [];
    if (!nodes.length) return;

    const indexMap = {};
    nodes.forEach((n, idx) => {
      indexMap[n.id] = idx;
    });

    const childrenMap = {};
    nodes.forEach(n => {
      const pid = n.parent_id;
      if (pid == null) return;
      if (!childrenMap[pid]) childrenMap[pid] = [];
      childrenMap[pid].push(n);
    });

    Object.keys(childrenMap).forEach(pid => {
      childrenMap[pid].sort((a, b) => indexMap[a.id] - indexMap[b.id]);
    });

    const rootNode =
      nodes.find(n => n.node_type === "root") ||
      nodes.find(n => n.parent_id == null) ||
      nodes[0];

    function renderNodeRecursive(node, parentEl) {
      const block = document.createElement("div");
      block.className = "sequence-node-block";

      const nodeEl = createSequenceNodeElement(seq, node);
      block.appendChild(nodeEl);

      const children = childrenMap[node.id] || [];
      if (children.length) {
        const childrenRow = document.createElement("div");
        childrenRow.className = "sequence-node-children";

        children.forEach(child => {
          const branchEl = document.createElement("div");
          branchEl.className = "sequence-node-branch";
          renderNodeRecursive(child, branchEl);
          childrenRow.appendChild(branchEl);
        });

        block.appendChild(childrenRow);
      }

      parentEl.appendChild(block);
    }

    if (rootNode) {
      renderNodeRecursive(rootNode, container);
    }
  }

  function renderOperationArea() {
    const container = document.getElementById("operation-area");
    container.innerHTML = "";

    const task = getCurrentTask();
    if (!task) {
      const hint = document.createElement("div");
      hint.className = "hint";
      hint.textContent = "ËØ∑ÂÖàÂú®Â∑¶‰æßÈÄâÊã©‰∏Ä‰∏™‰ªªÂä°„ÄÇ";
      container.appendChild(hint);
      return;
    }

    let sequences = sequenceNodesForTask(task.id);
    if (!sequences.length) {
      const hint = document.createElement("div");
      hint.className = "hint";
      hint.textContent = "Âú®Á¨¨‰∫åÊ†èÊüê‰∏™Êñá‰ª∂ÁªÑ‰∏äÂè≥ÈîÆÔºåÂàõÂª∫Êìç‰ΩúÂ∫èÂàóÁîªÊùø„ÄÇ";
      container.appendChild(hint);
      return;
    }

    // Á°Æ‰øùÊúâÊòæÁ§∫È°∫Â∫è
    ensureSequenceOrderForTask(task.id);

    // Êåâ display_index ÊéíÂ∫èÂ±ïÁ§∫
    sequences = sequences.slice().sort((a, b) => {
      const ai = (typeof a.display_index === "number") ? a.display_index : 0;
      const bi = (typeof b.display_index === "number") ? b.display_index : 0;
      return ai - bi;
    });

    sequences.forEach(seq => {
      const board = document.createElement("div");
      board.className = "sequence-board";
      board.dataset.sequenceId = seq.id;

      // ÂêØÁî®ÊãñÊãΩ
      board.setAttribute("draggable", "true");

      // ÊãñÊãΩ‰∫ã‰ª∂
      board.addEventListener("dragstart", (e) => {
        draggingSequenceId = seq.id;
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", seq.id);
        board.classList.add("dragging");
      });

      board.addEventListener("dragend", () => {
        draggingSequenceId = null;
        document
          .querySelectorAll(".sequence-board.drag-over-top, .sequence-board.drag-over-bottom, .sequence-board.dragging")
          .forEach(el => el.classList.remove("drag-over-top", "drag-over-bottom", "dragging"));
      });

      board.addEventListener("dragover", (e) => {
        if (!draggingSequenceId || draggingSequenceId === seq.id) return;
        e.preventDefault();
        const rect = board.getBoundingClientRect();
        const offsetY = e.clientY - rect.top;
        const isTopHalf = offsetY < rect.height / 2;

        board.classList.toggle("drag-over-top", isTopHalf);
        board.classList.toggle("drag-over-bottom", !isTopHalf);
      });

      board.addEventListener("dragleave", () => {
        board.classList.remove("drag-over-top", "drag-over-bottom");
      });

      board.addEventListener("drop", (e) => {
        if (!draggingSequenceId || draggingSequenceId === seq.id) return;
        e.preventDefault();

        const rect = board.getBoundingClientRect();
        const offsetY = e.clientY - rect.top;
        const isTopHalf = offsetY < rect.height / 2;

        reorderSequencesWithinTask(task.id, draggingSequenceId, seq.id, isTopHalf);
        draggingSequenceId = null;
        renderOperationArea();
      });

      const header = document.createElement("div");
      header.className = "sequence-header";
      header.dataset.nodeType = "sequence-board";
      header.dataset.sequenceId = seq.id;

      // Â∑¶‰æßÊäòÂè†/Â±ïÂºÄÂ∞è‰∏âËßí
      const collapsed = !!seq.collapsed;
      const arrow = document.createElement("span");
      arrow.className = "tree-arrow";
      arrow.textContent = collapsed ? "‚ñ∂" : "‚ñº";
      header.appendChild(arrow);

      // Ê†áÈ¢òÂå∫ÂüüÔºöÁ¨¨‰∏ÄË°åÊòæÁ§∫ [Êñá‰ª∂ÁªÑ] Êìç‰ΩúÂ∫èÂàóÂêçÁß∞ÔºåÁ¨¨‰∫åË°åÊòæÁ§∫‰ª£Á†Å‰øùÂ≠òË∑ØÂæÑ
      const title = document.createElement("div");
      title.className = "sequence-title";

      // Á¨¨‰∏ÄË°åÔºöÂéüÊù•ÁöÑÊ†áÈ¢ò
      const mainLine = document.createElement("div");
      mainLine.className = "sequence-title-main";
      const group = appState.file_groups[seq.file_group_id];
      const groupName = group ? group.name : "(Êú™Áü•Êñá‰ª∂ÁªÑ)";
      mainLine.textContent = `[${groupName}] ${seq.name}`;
      title.appendChild(mainLine);

      // Á¨¨‰∫åË°åÔºö‰ª£Á†Å‰øùÂ≠òË∑ØÂæÑÔºàÂßãÁªàÂàõÂª∫Ôºå‰æø‰∫éËæìÂÖ•Êó∂ÂÆûÊó∂Êõ¥Êñ∞Ôºâ
      const codeLine = document.createElement("div");
      codeLine.className = "sequence-code-path";
      codeLine.dataset.role = "code-save-path";
      codeLine.textContent = seq.code_save_path || "";
      codeLine.style.display = seq.code_save_path ? "block" : "none";
      title.appendChild(codeLine);

      // ÊääÊ†áÈ¢òÂùóÊåÇÂà∞ header ÈáåÔºàÂÖ≥ÈîÆÁöÑ‰∏ÄË°åÔºâ
      header.appendChild(title);

      board.appendChild(header);

      const meta = document.createElement("div");
      meta.className = "sequence-meta";
      const showMeta = !!seq.show_meta && !collapsed;
      meta.style.display = showMeta ? "block" : "none";

      const codeLabel = document.createElement("label");
      codeLabel.textContent = "‰ª£Á†Å‰øùÂ≠òË∑ØÂæÑÔºàÊîØÊåÅ {{var}}ÔºâÔºö";
      const codeInput = document.createElement("input");
      codeInput.value = seq.code_save_path || "";
      codeLabel.appendChild(codeInput);
      meta.appendChild(codeLabel);

      // ÂèñÂà∞Ê†áÈ¢òÁ¨¨‰∫åË°åÔºà‰∏äÈù¢ A1 Â∑≤‰øùËØÅ‰∏ÄÂÆöÂ≠òÂú®Ôºâ
      const codeLineEl = header.querySelector('[data-role="code-save-path"]');

      function commitCodeSavePath(skipHistory) {
        const v = (codeInput.value || "").trim();
        seq.code_save_path = v ? v : null;

        // ‚úÖ ÂõûÂÜôÔºöËÆ©ËæìÂÖ•Ê°Ü‰πüÂèòÊàê‚ÄúÂéªÁ©∫Ê†ºÂêéÁöÑÊ†∑Â≠ê‚Äù
        codeInput.value = v;

        // Ê†áÈ¢òÁ¨¨‰∫åË°åÂÆûÊó∂Êõ¥Êñ∞ + ÊòæÈöê
        if (codeLineEl) {
          codeLineEl.textContent = seq.code_save_path || "";
          codeLineEl.style.display = seq.code_save_path ? "block" : "none";
        }

        scheduleSaveState(!!skipHistory);
      }

      // ÂÆûÊó∂‰øùÂ≠òÔºà‰∏çËøõÊí§ÈîÄÊ†àÔºâ
      codeInput.addEventListener("input", () => commitCodeSavePath(true));
      // Êèê‰∫§‰øùÂ≠òÔºàËøõÊí§ÈîÄÊ†àÔºâ
      codeInput.addEventListener("change", () => commitCodeSavePath(false));
      codeInput.addEventListener("blur",   () => commitCodeSavePath(false));

      board.appendChild(meta);

      // Â∞è‰∏âËßíÁÇπÂáªÔºöÊäòÂè†/Â±ïÂºÄÊï¥‰∏™ÁîªÊùøÔºàmeta + nodesÔºâ
      arrow.addEventListener("click", (e) => {
        e.stopPropagation();
        seq.collapsed = !seq.collapsed;
        scheduleSaveState();
        renderOperationArea();
      });

      // Ê†áÈ¢òÂå∫ÂüüÁÇπÂáªÔºöÂàáÊç¢Ë∑ØÂæÑÈÖçÁΩÆÊòæÁ§∫ÔºõËã•ÂΩìÂâçÊòØÊäòÂè†Áä∂ÊÄÅÔºåÂàôÂÖàÂ±ïÂºÄ
      header.addEventListener("click", () => {
        if (seq.collapsed) {
          seq.collapsed = false;
        }
        seq.show_meta = !seq.show_meta;
        scheduleSaveState();
        renderOperationArea();
      });

      const nodesContainer = document.createElement("div");
      nodesContainer.className = "sequence-nodes";
      nodesContainer.style.display = collapsed ? "none" : "block";

      // Êñ∞ÔºöÊ†ëÂΩ¢Ê∏≤ÊüìÔºåÊîØÊåÅÊ®™ÂêëÂàÜÊîØ
      renderSequenceTree(seq, nodesContainer);

      board.appendChild(nodesContainer);
      container.appendChild(board);
    });

    // Ê∏≤ÊüìÂÆåÂêéÊ†πÊçÆ executed Áä∂ÊÄÅÂà∑Êñ∞Ê†∑Âºè
    applyExecutionStyles();
  }

  // ===========
  // Âè≥ÈîÆËèúÂçï
  // ===========

  const contextMenuEl = document.getElementById("context-menu");
  let contextTarget = null;

  function hideContextMenu() {
    contextMenuEl.style.display = "none";
    contextMenuEl.innerHTML = "";
    contextTarget = null;
  }

  document.addEventListener("click", () => {
    hideContextMenu();
  });

  let copiedTaskIdForFullCopy = null;
  let copiedSequenceTemplate = null; 
  let copiedOpNodeTemplate = null; // Áî®‰∫éÂ≠òÂÇ®Â§çÂà∂ÁöÑ op ËäÇÁÇπÊ®°Êùø

  function showContextMenu(type, payload, pageX, pageY) {
    contextTarget = { type, payload };
    contextMenuEl.innerHTML = "";
    function addItem(text, action) {
      const div = document.createElement("div");
      div.className = "context-menu-item";
      div.textContent = text;
      div.dataset.action = action;
      contextMenuEl.appendChild(div);
    }
    function addDivider() {
      const div = document.createElement("div");
      div.className = "context-menu-divider";
      contextMenuEl.appendChild(div);
    }

    // Á¨¨‰∏ÄÂàóÔºöÁ©∫ÁôΩ & ÁõÆÂΩï & ‰ªªÂä°
    if (type === "task-empty") {
      addItem("ÂàõÂª∫ÁõÆÂΩï", "create-directory-root");
    } else if (type === "directory") {
      addItem("ÁõÆÂΩïÈáçÂëΩÂêç", "rename-directory");
      addItem("Âà†Èô§ÁõÆÂΩï", "delete-directory");
      addItem("Â§çÂà∂ÁõÆÂΩïÂêçÁß∞", "copy-directory-name");
      addDivider();
      addItem("ÂàõÂª∫Â≠êÁõÆÂΩï", "create-sub-directory");
      addItem("ÂàõÂª∫‰ªªÂä°", "create-task");
      addDivider();
      addItem("Á≤òË¥¥‰ªªÂä°ÔºàÂÆåÊï¥ÂâØÊú¨Ôºâ", "paste-task");
    } else if (type === "task") {
      addItem("‰ªªÂä°ÈáçÂëΩÂêç", "rename-task");
      addItem("Âà†Èô§‰ªªÂä°", "delete-task");
      addItem("Â§çÂà∂‰ªªÂä°ÂêçÁß∞", "copy-task-name");
      addItem("Â§çÂà∂ÂÆåÊï¥‰ªªÂä°ÔºàÂåÖÂê´Êñá‰ª∂ÁªÑÂíåÊìç‰ΩúÂ∫èÂàóÔºâ", "copy-task-full");
    }

    // Á¨¨‰∫åÂàóÔºöÊñá‰ª∂ÁªÑÂå∫Âüü
    if (type === "group-empty") {
      addItem("ÂàõÂª∫Êñá‰ª∂ÁªÑ", "create-file-group");
    } else if (type === "file-group") {
      addItem("Êñá‰ª∂ÁªÑÈáçÂëΩÂêç", "rename-file-group");
      addItem("Âà†Èô§Êñá‰ª∂ÁªÑ", "delete-file-group");
      addItem("Â§çÂà∂Êñá‰ª∂ÁªÑÂêçÁß∞", "copy-file-group-name");
      addDivider();
      addItem("Ê∑ªÂä†Êñá‰ª∂Ë∑ØÂæÑÔºàÂ§öË°åÔºåÊîØÊåÅÈÄöÈÖçÁ¨¶Ôºâ", "add-file-paths");
      addDivider();
      addItem("Âú®Á¨¨ÂõõÊ†èÂàõÂª∫Êìç‰ΩúÂ∫èÂàóÁîªÊùø", "create-sequence-board");
      if (copiedSequenceTemplate) {
        addDivider();
        const fromName = copiedSequenceTemplate.fromTaskName;
        addItem(`Á≤òË¥¥Êìç‰ΩúÂ∫èÂàóÔºàÊù•Ëá™‰ªªÂä°Ôºö${fromName}Ôºâ`, "paste-sequence");
      }
    } else if (type === "file-path") {
      addItem("Âà†Èô§Êñá‰ª∂Ë∑ØÂæÑ", "delete-file-path");
      addItem("Â§çÂà∂Êñá‰ª∂Ë∑ØÂæÑ", "copy-file-path");
      addItem("‰øÆÊîπÊñá‰ª∂Ë∑ØÂæÑ", "edit-file-path");
      addDivider();
      addItem("Â§çÂà∂ÈùûÁ©∫Á¨¨‰∏ÄË°åÊï∞ÊçÆÂÜÖÂÆπ", "copy-first-line");
      addItem("Â§çÂà∂ÈùûÁ©∫ÊúÄÂêé‰∏ÄË°åÊï∞ÊçÆÂÜÖÂÆπ", "copy-last-line");
      addItem("ÊòæÁ§∫Êñá‰ª∂Ë∑ØÂæÑ‰ø°ÊÅØÔºàÊñá‰ª∂Êï∞ & ÊÄªË°åÊï∞Ôºâ", "show-file-info");
    }

    // Á¨¨ÂõõÂàóÔºöÊìç‰ΩúÂ∫èÂàó & ËäÇÁÇπ
    if (type === "sequence-board") {
      addItem("ÈáçÂëΩÂêçÊìç‰ΩúÂ∫èÂàó", "rename-sequence-board");
      addItem("Â§çÂà∂Êï¥‰∏™Êìç‰ΩúÂ∫èÂàóÔºàÂÆåÊï¥Ôºâ", "copy-sequence-full");
      addDivider();
      addItem("ÁîüÊàêÂèØÊâßË°å‰ª£Á†Å", "generate-code");
      addItem("Âú®ÂÆåÊï¥Êï∞ÊçÆ‰∏äÊâßË°åÊìç‰ΩúÂ∫èÂàó", "run-sequence");
      addDivider();
      addItem("Âà†Èô§ËØ•Êìç‰ΩúÂ∫èÂàóÁîªÊùø", "delete-sequence-board");
    } else if (type === "root-node") {
      const seqId = payload.sequenceId;
      const nodeId = payload.nodeId;
      const seq = appState.operation_sequences[seqId];
      const node = seq ? (seq.nodes || []).find(n => n.id === nodeId) : null;

      if (node && node.executed) addItem("Ê†áËÆ∞‰∏∫Êú™ÂÆåÊàêÔºàexecuted=falseÔºåÂ≠êÊ†ëÊ∏ÖÁ©∫Ôºâ", "set-executed-false");
      else addItem("Ê†áËÆ∞‰∏∫Â∑≤ÂÆåÊàêÔºàexecuted=trueÔºåÁà∂ÈìæË°•ÈΩêÔºâ", "set-executed-true");
      addDivider();

      addItem("Âú®ËØ•ËäÇÁÇπÂêéÁ∫øÊÄßÊèíÂÖ•ËäÇÁÇπ", "insert-linear-node");
      addItem("Âú®ËØ•ËäÇÁÇπÂêéÊèíÂÖ•Â≠êËäÇÁÇπÔºàÊñ∞ÂàÜÊîØÔºâ", "insert-child-node");
      if (copiedOpNodeTemplate) {
        addDivider();
        addItem("Á∫øÊÄßÁ≤òË¥¥Â∑≤Â§çÂà∂ËäÇÁÇπ", "paste-op-node-linear");
        addItem("Âú®ËØ•ËäÇÁÇπÂêéÁ≤òË¥¥‰∏∫Êñ∞ÂàÜÊîØ", "paste-op-node-below");
      }
    } else if (type === "op-node") {
      const seqId = payload.sequenceId;
      const nodeId = payload.nodeId;
      const seq = appState.operation_sequences[seqId];
      const node = seq ? seq.nodes.find(n => n.id === nodeId) : null;
      
      if (node) {
        if (node.frozen) {
          addItem("Ëß£ÂÜªËØ•ËäÇÁÇπÂèäÂ≠êËäÇÁÇπ", "toggle-freeze-node");
        } else {
          addItem("ÂÜªÁªìËØ•ËäÇÁÇπÂèäÂ≠êËäÇÁÇπ (ÂøΩÁï•ÊâßË°å)", "toggle-freeze-node");
        }
        addDivider();
      }
      if (node) {
        if (node.executed) addItem("Ê†áËÆ∞‰∏∫Êú™ÂÆåÊàêÔºàexecuted=falseÔºåÂ≠êÊ†ëÊ∏ÖÁ©∫Ôºâ", "set-executed-false");
        else addItem("Ê†áËÆ∞‰∏∫Â∑≤ÂÆåÊàêÔºàexecuted=trueÔºåÁà∂ÈìæË°•ÈΩêÔºâ", "set-executed-true");
        addDivider();
      }
      // ÊôÆÈÄö op ËäÇÁÇπÔºöÂêåÊ†∑ÊîØÊåÅÁ∫øÊÄßÊèíÂÖ• / Á∫øÊÄßÁ≤òË¥¥ + ÂéüÊúâÊìç‰Ωú
      addItem("Âú®ËØ•ËäÇÁÇπÂêéÁ∫øÊÄßÊèíÂÖ•ËäÇÁÇπ", "insert-linear-node");
      addItem("Âú®ËØ•ËäÇÁÇπÂêéÊèíÂÖ•Â≠êËäÇÁÇπÔºàÊñ∞ÂàÜÊîØÔºâ", "insert-child-node");
      // addItem("Âú®ËØ•ËäÇÁÇπÂêéÊèíÂÖ•Â§ö‰∏™Â≠êËäÇÁÇπÔºàÂ§öÂàÜÊîØÔºâ", "insert-multi-child-nodes");
      addItem("Âà†Èô§ËØ•Â≠êËäÇÁÇπÔºàËøûÂ∏¶ÂêéÁª≠ÈìæË∑ØÔºâ", "delete-child-node");
      addItem("Âà†Èô§ËØ•ËäÇÁÇπÂπ∂Ê°•Êé•ÂâçÂêéÈìæË∑Ø", "delete-child-node-bridge");
      addDivider();
      addItem("Â§çÂà∂ËØ•ËäÇÁÇπ", "copy-op-node");
      if (copiedOpNodeTemplate) {
        addItem("Á∫øÊÄßÁ≤òË¥¥Â∑≤Â§çÂà∂ËäÇÁÇπ", "paste-op-node-linear");
        addItem("Âú®ËØ•ËäÇÁÇπÂêéÁ≤òË¥¥‰∏∫Êñ∞ÂàÜÊîØ", "paste-op-node-below");
      }
    }


    if (!contextMenuEl.children.length) {
      return;
    }

    contextMenuEl.style.left = pageX + "px";
    contextMenuEl.style.top = pageY + "px";
    contextMenuEl.style.display = "block";
  }

  contextMenuEl.addEventListener("click", async e => {
    e.stopPropagation();
    const item = e.target.closest(".context-menu-item");
    if (!item || !contextTarget) return;
    const action = item.dataset.action;
    const { type, payload } = contextTarget;
    hideContextMenu();
    await handleContextAction(type, action, payload);
    renderAll();
  });

  // ===========
  // Âè≥ÈîÆËèúÂçïÂä®‰ΩúÂÆûÁé∞
  // ===========

  async function handleContextAction(type, action, payload) {
    // Á¨¨‰∏ÄÂàóÔºöÁõÆÂΩï/‰ªªÂä°
    if (type === "task-empty") {
      if (action === "create-directory-root") {
        const name = prompt("ËØ∑ËæìÂÖ•ÁõÆÂΩïÂêçÁß∞Ôºö", "Êñ∞Âª∫ÁõÆÂΩï");
        if (!name) return;
        const id = createId();
        appState.directories[id] = {
          id,
          name: name.trim(),
          parent_id: "root",
          collapsed: false,
          display_index: getMaxTreeDisplayIndex("root") + 1
        };
        scheduleSaveState();
      }
    } else if (type === "directory") {
      const dirId = payload.id;
      const dir = appState.directories[dirId];
      if (!dir) return;

      if (action === "rename-directory") {
        const newName = prompt("ËØ∑ËæìÂÖ•Êñ∞ÁöÑÁõÆÂΩïÂêçÁß∞Ôºö", dir.name);
        if (!newName) return;
        dir.name = newName.trim();
        scheduleSaveState();
      } else if (action === "delete-directory") {
        const ok = confirm("Á°ÆÂÆöË¶ÅÂà†Èô§ËØ•ÁõÆÂΩïÂèäÂÖ∂ÊâÄÊúâÂ≠êÁõÆÂΩïÂíå‰ªªÂä°ÂêóÔºüËØ•Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ");
        if (!ok) return;
        const toDeleteDirIds = new Set([dirId]);
        let changed = true;
        while (changed) {
          changed = false;
          for (const id in appState.directories) {
            const d = appState.directories[id];
            if (d.parent_id && toDeleteDirIds.has(d.parent_id) && !toDeleteDirIds.has(id)) {
              toDeleteDirIds.add(id);
              changed = true;
            }
          }
        }
        const toDeleteTaskIds = [];
        for (const taskId in appState.tasks) {
          const t = appState.tasks[taskId];
          const pid = t.directory_id || "root";
          if (toDeleteDirIds.has(pid)) {
            toDeleteTaskIds.push(taskId);
          }
        }
        toDeleteTaskIds.forEach(taskId => {
          delete appState.tasks[taskId];
          for (const fgId in appState.file_groups) {
            if (appState.file_groups[fgId].task_id === taskId) {
              delete appState.file_groups[fgId];
            }
          }
          for (const seqId in appState.operation_sequences) {
            if (appState.operation_sequences[seqId].task_id === taskId) {
              delete appState.operation_sequences[seqId];
            }
          }
        });
        toDeleteDirIds.forEach(id => {
          delete appState.directories[id];
        });
        if (uiState.currentTaskId && !appState.tasks[uiState.currentTaskId]) {
          uiState.currentTaskId = null;
        }
        scheduleSaveState();
      } else if (action === "copy-directory-name") {
        copyToClipboard(dir.name || "");
      } else if (action === "create-sub-directory") {
        const name = prompt("ËØ∑ËæìÂÖ•Â≠êÁõÆÂΩïÂêçÁß∞Ôºö", "Êñ∞Âª∫Â≠êÁõÆÂΩï");
        if (!name) return;
        const id = createId();
        appState.directories[id] = {
          id,
          name: name.trim(),
          parent_id: dirId,
          collapsed: false,
          display_index: getMaxTreeDisplayIndex(dirId) + 1
        };
        scheduleSaveState();
      } else if (action === "create-task") {
        let baseName = "Êñ∞Âª∫‰ªªÂä°";
        const siblings = Object.values(appState.tasks).filter(
          t => (t.directory_id || "root") === dirId
        ).map(t => t.name);
        const name = prompt(
          "ËØ∑ËæìÂÖ•‰ªªÂä°ÂêçÁß∞Ôºö",
          generateUniqueName(baseName, siblings)
        );
        if (!name) return;
        const id = createId();
        appState.tasks[id] = {
          id,
          name: name.trim(),
          directory_id: dirId,
          vars: {},   // Êñ∞‰ªªÂä°ÂàùÂßãÂèòÈáè
          display_index: getMaxTreeDisplayIndex(dirId) + 1
        };
        uiState.currentTaskId = id;
        scheduleSaveState();
      } else if (action === "paste-task") {
        if (!copiedTaskIdForFullCopy || !appState.tasks[copiedTaskIdForFullCopy]) {
          showMessage("ÂΩìÂâçÊ≤°ÊúâÂèØÁ≤òË¥¥ÁöÑ‰ªªÂä°ÔºåËØ∑ÂÖàÂú®‰ªªÂä°‰∏äÈÄâÊã©‚ÄúÂ§çÂà∂ÂÆåÊï¥‰ªªÂä°‚Äù„ÄÇ");
          return;
        }
        const srcTask = appState.tasks[copiedTaskIdForFullCopy];
        const siblings = Object.values(appState.tasks).filter(
          t => (t.directory_id || "root") === dirId
        ).map(t => t.name);
        let baseName = srcTask.name + "_ÂâØÊú¨";
        let newName = baseName + " 1";
        let idx = 1;
        while (siblings.includes(newName)) {
          idx++;
          newName = baseName + " " + idx;
        }
        const finalName = prompt("ËØ∑ËæìÂÖ•Êñ∞‰ªªÂä°ÂêçÁß∞Ôºö", newName) || newName;
        const newTaskId = createId();
        appState.tasks[newTaskId] = {
          id: newTaskId,
          name: finalName.trim(),
          directory_id: dirId,
          vars: srcTask.vars ? { ...srcTask.vars } : {},
          display_index: getMaxTreeDisplayIndex(dirId) + 1
        };

        const oldGroups = Object.values(appState.file_groups).filter(
          g => g.task_id === srcTask.id
        );
        const groupIdMap = {};
        oldGroups.forEach(g => {
          const newGroupId = createId();
          groupIdMap[g.id] = newGroupId;
          appState.file_groups[newGroupId] = {
            id: newGroupId,
            name: g.name,
            task_id: newTaskId,
            collapsed: g.collapsed,
            display_index: g.display_index,
            file_paths: (g.file_paths || []).map(fp => ({
              id: createId(),
              path: fp.path,
              info: fp.info ? { ...fp.info } : null
            }))
          };
        });

        const oldSeqs = Object.values(appState.operation_sequences).filter(
          s => s.task_id === srcTask.id
        );

        oldSeqs.forEach(seq => {
          const newSeqId = createId();
          const newGroupId = groupIdMap[seq.file_group_id];
          if (!newGroupId) return;

          const oldNodes = Array.isArray(seq.nodes) ? seq.nodes : [];
          const idMap = {};
          const newNodes = oldNodes.map((n, index) => {
            const newId = createId();
            idMap[n.id] = newId;
            return {
              id: newId,
              node_type: n.node_type,
              name: n.name,
              function_name: n.function_name,
              params_json: n.params_json,
              description: n.description,
              result_save_path: n.result_save_path || (n.node_type === "op" ? "" : null),
              executed: false,   // ÂâØÊú¨ÂÖ®ÈÉ®ÈáçÁΩÆ‰∏∫Êú™ÊâßË°å
              parent_id: null    // ÂÖàÂç†‰ΩçÔºå‰∏ã‰∏ÄÊ≠•ÂÜçÂ°´
            };
          });

          // Á¨¨‰∫åËΩÆÔºöÊ†πÊçÆÊóß parent_id Áî® idMap Êò†Â∞ÑÂà∞Êñ∞ÁöÑËäÇÁÇπ id
          newNodes.forEach((newNode, index) => {
            const oldNode = oldNodes[index];
            const oldPid = oldNode.parent_id;

            if (oldPid == null) {
              // Ê†πËäÇÁÇπ
              newNode.parent_id = null;
            } else if (idMap[oldPid]) {
              // Ê≠£Â∏∏ÊÉÖÂÜµÔºöËÉΩÂú® idMap ÈáåÊâæÂà∞ÂØπÂ∫îÁöÑÊñ∞Áà∂ËäÇÁÇπ
              newNode.parent_id = idMap[oldPid];
            } else {
              // ÂÖúÂ∫ïÔºö‰∏á‰∏ÄÊóßÊï∞ÊçÆ parent_id ÂºÇÂ∏∏ÔºåÂ∞±ÊåâÁ∫øÊÄßÈìæÂ§ÑÁêÜ
              newNode.parent_id = index === 0 ? null : newNodes[index - 1].id;
            }
          });
          // ‚úÖ Êää params_json ÈáåÂºïÁî®‚ÄúÊóßÂ∫èÂàóÂÜÖÈÉ®ËäÇÁÇπËæìÂá∫‚ÄùÁöÑ $ref ÈáçÂÜôÊàêÊñ∞Â∫èÂàó/Êñ∞ËäÇÁÇπ
          newNodes.forEach(n => {
            if (n.node_type !== "op") return;

            n.params_json = rewriteRefsInParamsJson(n.params_json, (ref) => {
              if (ref.kind !== "node_output") return null;

              // Âè™ÈáçÂÜô‚ÄúÊåáÂêëË¢´Â§çÂà∂ÁöÑÈÇ£Êù°ÊóßÂ∫èÂàó‚ÄùÁöÑÂºïÁî®ÔºàÈÅøÂÖçËØØ‰º§Ë∑®Â∫èÂàóÂºïÁî®Ôºâ
              if (ref.sequence_id !== seq.id) return null;

              const mappedNodeId = idMap[ref.node_id];
              if (!mappedNodeId) return null;

              return {
                ...ref,
                sequence_id: newSeqId,
                node_id: mappedNodeId
              };
            });
          });

          appState.operation_sequences[newSeqId] = {
            id: newSeqId,
            name: seq.name,
            task_id: newTaskId,
            file_group_id: newGroupId,
            code_save_path: seq.code_save_path,
            show_meta: seq.show_meta || false,
            collapsed: seq.collapsed || false,
            display_index: typeof seq.display_index === "number" ? seq.display_index : 0,
            nodes: newNodes
          };
        });

        uiState.currentTaskId = newTaskId;
        scheduleSaveState();
      }
    } else if (type === "task") {
      const taskId = payload.id;
      const task = appState.tasks[taskId];
      if (!task) return;

      if (action === "rename-task") {
        const newName = prompt("ËØ∑ËæìÂÖ•Êñ∞ÁöÑ‰ªªÂä°ÂêçÁß∞Ôºö", task.name);
        if (!newName) return;
        const siblings = Object.values(appState.tasks).filter(
          t => (t.directory_id || "root") === (task.directory_id || "root") && t.id !== taskId
        ).map(t => t.name);
        if (siblings.includes(newName.trim())) {
          showMessage("Âêå‰∏ÄÁõÆÂΩï‰∏ã‰ªªÂä°ÂêçÁß∞‰∏çÂæóÈáçÂ§ç„ÄÇ");
          return;
        }
        task.name = newName.trim();
        scheduleSaveState();
      } else if (action === "delete-task") {
        const ok = confirm("Á°ÆÂÆöË¶ÅÂà†Èô§ËØ•‰ªªÂä°ÂèäÂÖ∂Êñá‰ª∂ÁªÑ„ÄÅÊìç‰ΩúÂ∫èÂàóÂêóÔºü");
        if (!ok) return;
        delete appState.tasks[taskId];
        for (const fgId in appState.file_groups) {
          if (appState.file_groups[fgId].task_id === taskId) {
            delete appState.file_groups[fgId];
          }
        }
        for (const seqId in appState.operation_sequences) {
          if (appState.operation_sequences[seqId].task_id === taskId) {
            delete appState.operation_sequences[seqId];
          }
        }
        if (uiState.currentTaskId === taskId) {
          uiState.currentTaskId = null;
        }
        scheduleSaveState();
      } else if (action === "copy-task-name") {
        copyToClipboard(task.name || "");
      } else if (action === "copy-task-full") {
        copiedTaskIdForFullCopy = taskId;
        showMessage("Â∑≤Â§çÂà∂ÂÆåÊï¥‰ªªÂä°ÔºåÂèØ‰ª•Âú®ÁõÆÂΩï‰∏äÂè≥ÈîÆÈÄâÊã©‚ÄúÁ≤òË¥¥‰ªªÂä°‚Äù„ÄÇ");
      }
    }

    // Á¨¨‰∫åÂàóÔºöÊñá‰ª∂ÁªÑ & Êñá‰ª∂Ë∑ØÂæÑ
    if (type === "group-empty") {
      if (action === "create-file-group") {
        const task = getCurrentTask();
        if (!task) {
          showMessage("ËØ∑ÂÖàÈÄâ‰∏≠‰∏Ä‰∏™‰ªªÂä°„ÄÇ");
          return;
        }
        const existingNames = groupsForTask(task.id).map(g => g.name);
        const defaultName = generateUniqueName("Á¨¨‰∏ÄÁªÑ", existingNames);
        const name = prompt("ËØ∑ËæìÂÖ•Êñá‰ª∂ÁªÑÂêçÁß∞Ôºö", defaultName);
        if (!name) return;

        const existingGroups = groupsForTask(task.id);
        const maxIndex = existingGroups.reduce((m, g) => {
          const v = (typeof g.display_index === "number") ? g.display_index : m;
          return Math.max(m, v);
        }, -1);

        const id = createId();
        appState.file_groups[id] = {
          id,
          name: name.trim(),
          task_id: task.id,
          file_paths: [],
          collapsed: false,
          display_index: maxIndex + 1
        };
        scheduleSaveState();
      }
    } else if (type === "file-group") {
      const groupId = payload.groupId;
      const group = appState.file_groups[groupId];
      if (!group) return;

      if (action === "rename-file-group") {
        const task = getCurrentTask();
        if (!task) {
          showMessage("‰ªªÂä°‰∏çÂ≠òÂú®„ÄÇ");
          return;
        }
        const existingNames = groupsForTask(task.id)
          .filter(g => g.id !== groupId)
          .map(g => g.name);
        const newName = prompt("ËØ∑ËæìÂÖ•Êñ∞ÁöÑÊñá‰ª∂ÁªÑÂêçÁß∞Ôºö", group.name);
        if (!newName) return;
        const trimmed = newName.trim();
        if (existingNames.includes(trimmed)) {
          showMessage("Âêå‰∏Ä‰ªªÂä°‰∏ãÊñá‰ª∂ÁªÑÂêçÁß∞‰∏çÂæóÈáçÂ§ç„ÄÇ");
          return;
        }

        // 1. Êõ¥Êñ∞Êñá‰ª∂ÁªÑÂêçÁß∞
        group.name = trimmed;

        // 2. ÂêåÊ≠•Êõ¥Êñ∞ÊâÄÊúâÁªëÂÆöÂà∞ËØ•Êñá‰ª∂ÁªÑÁöÑÊìç‰ΩúÂ∫èÂàó‰∏≠ÁöÑ root ËäÇÁÇπÊòæÁ§∫ÂêçÁß∞
        for (const seqId in appState.operation_sequences) {
          const seq = appState.operation_sequences[seqId];
          if (seq.file_group_id === groupId && Array.isArray(seq.nodes)) {
            const rootNode = seq.nodes.find(n => n.node_type === "root");
            if (rootNode) {
              rootNode.name = trimmed;
            }
          }
        }

        scheduleSaveState();
      } else if (action === "delete-file-group") {
        const ok = confirm("Âà†Èô§Êñá‰ª∂ÁªÑ‰ºöÂêåÊó∂Âà†Èô§ËØ•ÁªÑ‰∏ãÊâÄÊúâË∑ØÂæÑÂèäÁªëÂÆöÁöÑÊìç‰ΩúÂ∫èÂàóÔºåÁ°ÆÂÆöÔºü");
        if (!ok) return;
        delete appState.file_groups[groupId];
        for (const seqId in appState.operation_sequences) {
          if (appState.operation_sequences[seqId].file_group_id === groupId) {
            delete appState.operation_sequences[seqId];
          }
        }
        scheduleSaveState();
      } else if (action === "copy-file-group-name") {
        copyToClipboard(group.name || "");
      } else if (action === "add-file-paths") {
        const text = prompt(
          "ËØ∑ËæìÂÖ•Êñá‰ª∂Ë∑ØÂæÑÔºàÂøÖÈ°ª‰∏∫ÁªùÂØπË∑ØÂæÑÔºåÊîØÊåÅÈÄöÈÖçÁ¨¶ÔºåÂèØÁî® {{var}} Âç†‰ΩçÁ¨¶ÔºâÔºåÂèØÂ§öË°åËæìÂÖ•Ôºö",
          ""
        );
        if (!text) return;
        const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
        const existingPaths = new Set(
          (group.file_paths || []).map(fp => fp.path)
        );
        lines.forEach(line => {
          if (existingPaths.has(line)) return;
          const id = createId();
          group.file_paths.push({
            id,
            path: line,
            info: null
          });
          existingPaths.add(line);
        });
        scheduleSaveState();
      } else if (action === "create-sequence-board") {
        const task = getCurrentTask();
        if (!task) {
          showMessage("ËØ∑ÂÖàÈÄâ‰∏≠‰∏Ä‰∏™‰ªªÂä°„ÄÇ");
          return;
        }
        const defaultName = "Êìç‰ΩúÂ∫èÂàó";
        const existingNames = sequenceNodesForTask(task.id).map(s => s.name);
        const name = prompt(
          "ËØ∑ËæìÂÖ•Êìç‰ΩúÂ∫èÂàóÂêçÁß∞Ôºö",
          generateUniqueName(defaultName, existingNames)
        );
        if (!name) return;

        const seqId = createId();
        const rootNodeId = createId();

        const existingSeqs = sequenceNodesForTask(task.id);
        const maxIndex = existingSeqs.reduce((m, s) => {
          const v = (typeof s.display_index === "number") ? s.display_index : m;
          return Math.max(m, v);
        }, -1);

        appState.operation_sequences[seqId] = {
          id: seqId,
          name: name.trim(),
          task_id: task.id,
          file_group_id: groupId,
          code_save_path: null,
          show_meta: false,
          collapsed: false,
          display_index: maxIndex + 1,
          nodes: [
            {
              id: rootNodeId,
              node_type: "root",
              name: group.name,
              function_name: null,
              params_json: "{}",
              description: "Ê†πËäÇÁÇπÔºöÊñá‰ª∂ÁªÑÂêàÂπ∂ÂêéÁöÑÊï∞ÊçÆ",
              result_save_path: null,   // root Ê≤°ÊúâË∑ØÂæÑÔºå‰ªÖÂç†‰Ωç
              executed: false,
              parent_id: null           // Êñ∞Â¢ûÔºöÊ†πËäÇÁÇπ parent_id Âõ∫ÂÆö‰∏∫ null
            }
          ]
        };
        scheduleSaveState();
      } else if (action === "paste-sequence") {
        if (!copiedSequenceTemplate) {
          showMessage("ÂΩìÂâçÊ≤°ÊúâÂèØÁ≤òË¥¥ÁöÑÊìç‰ΩúÂ∫èÂàó„ÄÇ");
          return;
        }

        const group = appState.file_groups[groupId];
        if (!group) return;

        const targetTaskId = group.task_id;
        const targetTask = appState.tasks[targetTaskId];
        if (!targetTask) {
          showMessage("ÁõÆÊ†áÊñá‰ª∂ÁªÑÊâÄÂ±û‰ªªÂä°‰∏çÂ≠òÂú®„ÄÇ");
          return;
        }

        const { seq: srcSeq, fromTaskId, fromTaskName } = copiedSequenceTemplate;

        // ====== Ë∑®‰ªªÂä°ÊèêÁ§∫ÔºàÂè™Âú®Ë∑®‰ªªÂä°Êó∂Âá∫Áé∞Ôºâ ======
        if (fromTaskId !== targetTaskId) {
          const ok = confirm(
            `ËØ•Êìç‰ΩúÂ∫èÂàóÊù•Ëá™‰ªªÂä°„Äê${fromTaskName}„ÄëÔºå\n` +
            `Âç≥Â∞ÜÁ≤òË¥¥Âà∞‰ªªÂä°„Äê${targetTask.name}„Äë„ÄÇ\n\n` +
            `ËØ∑Á°ÆËÆ§Ôºö\n` +
            `1. ‰∏§‰∏™‰ªªÂä°ÁöÑÊï∞ÊçÆÁªìÊûÑÊòØÂÖºÂÆπÁöÑ\n` +
            `2. ÊâÄÁî® {{var}} Âú®ÁõÆÊ†á‰ªªÂä°‰∏≠Â∑≤ÂÆö‰πâ\n\n` +
            `ÊòØÂê¶ÁªßÁª≠Ôºü`
          );
          if (!ok) return;
        }

        // ===== Êñ∞ sequence ID =====
        const newSeqId = createId();

        // ===== display_indexÔºöÊéíÂà∞ÊúÄÂêé =====
        const existingSeqs = sequenceNodesForTask(targetTaskId);
        const maxIndex = existingSeqs.reduce((m, s) => {
          const v = (typeof s.display_index === "number") ? s.display_index : m;
          return Math.max(m, v);
        }, -1);

        // ===== Â§çÂà∂ nodes & ÈáçÂª∫ id Êò†Â∞Ñ =====
        const oldNodes = Array.isArray(srcSeq.nodes) ? srcSeq.nodes : [];
        const idMap = {};
        const newNodes = oldNodes.map(oldNode => {
          const newId = createId();
          idMap[oldNode.id] = newId;
          return {
            ...oldNode,
            id: newId,
            executed: false,   // Ë∑®‰ªªÂä°ÂøÖÈ°ªÂÖ®ÈÉ®ÈáçÁΩÆ
            parent_id: null
          };
        });

        // ===== ‰øÆÂ§ç parent_id =====
        newNodes.forEach((newNode, index) => {
          const oldNode = oldNodes[index];
          if (oldNode.parent_id == null) {
            newNode.parent_id = null;
          } else if (idMap[oldNode.parent_id]) {
            newNode.parent_id = idMap[oldNode.parent_id];
          } else {
            // ÂÖúÂ∫ïÈÄÄÂåñ
            newNode.parent_id = index === 0 ? null : newNodes[index - 1].id;
          }
        });

        // ‚úÖ Êää params_json ÈáåÂºïÁî®‚ÄúÊóßÂ∫èÂàóÂÜÖÈÉ®ËäÇÁÇπËæìÂá∫‚ÄùÁöÑ $ref ÈáçÂÜôÊàêÊñ∞Â∫èÂàó/Êñ∞ËäÇÁÇπ
        newNodes.forEach(n => {
          if (n.node_type !== "op") return;

          n.params_json = rewriteRefsInParamsJson(n.params_json, (ref) => {
            if (ref.kind !== "node_output") return null;

            // Âè™ÈáçÂÜô‚ÄúÊåáÂêëË¢´Â§çÂà∂ÁöÑÈÇ£Êù°ÊóßÂ∫èÂàó‚ÄùÁöÑÂºïÁî®ÔºàÈÅøÂÖçËØØ‰º§Ë∑®Â∫èÂàóÂºïÁî®Ôºâ
            if (ref.sequence_id !== srcSeq.id) return null;

            const mappedNodeId = idMap[ref.node_id];
            if (!mappedNodeId) return null;

            return {
              ...ref,
              sequence_id: newSeqId,
              node_id: mappedNodeId
            };
          });
        });

        // ===== root ËäÇÁÇπÂêçÁß∞ÂêåÊ≠•‰∏∫ÁõÆÊ†áÊñá‰ª∂ÁªÑÂêç =====
        const rootNode = newNodes.find(n => n.node_type === "root");
        if (rootNode) {
          rootNode.name = group.name;
        }

        // ===== ÊúÄÁªàÁîüÊàêÊñ∞ÁöÑÊìç‰ΩúÂ∫èÂàó =====
        appState.operation_sequences[newSeqId] = {
          id: newSeqId,
          name: srcSeq.name + "ÔºàË∑®‰ªªÂä°ÂâØÊú¨Ôºâ",
          task_id: targetTaskId,
          file_group_id: groupId,
          code_save_path: srcSeq.code_save_path,
          show_meta: false,
          collapsed: false,
          display_index: maxIndex + 1,
          nodes: newNodes
        };

        scheduleSaveState();
      }
    } else if (type === "file-path") {
      const { groupId, filePathId } = payload;
      const group = appState.file_groups[groupId];
      if (!group) return;
      const idx = (group.file_paths || []).findIndex(fp => fp.id === filePathId);
      if (idx === -1) return;
      const fp = group.file_paths[idx];
      const taskId = group.task_id;

      if (action === "delete-file-path") {
        group.file_paths.splice(idx, 1);
        if (uiState.selectedFilePathId === filePathId) {
          uiState.selectedFilePathId = null;
          uiState.fieldStructure = null;
        }
        scheduleSaveState();
      } else if (action === "copy-file-path") {
        copyToClipboard(fp.path || "");
      } else if (action === "edit-file-path") {
        const newPath = prompt("ËØ∑ËæìÂÖ•Êñ∞ÁöÑÊñá‰ª∂Ë∑ØÂæÑÔºàÁªùÂØπË∑ØÂæÑÔºåÊîØÊåÅÈÄöÈÖçÁ¨¶ÔºåÂèØÁî® {{var}}ÔºâÔºö", fp.path);
        if (!newPath) return;
        const trimmed = newPath.trim();
        const exists = (group.file_paths || []).some(
          other => other.id !== filePathId && other.path === trimmed
        );
        if (exists) {
          showMessage("Âêå‰∏ÄÊñá‰ª∂ÁªÑ‰∏ãÊñá‰ª∂Ë∑ØÂæÑ‰∏çÂæóÈáçÂ§ç„ÄÇ");
          return;
        }
        fp.path = trimmed;
        fp.info = null;
        if (uiState.selectedFilePathId === filePathId) {
          uiState.fieldStructure = null;
        }
        scheduleSaveState();
      } else if (action === "show-file-info") {
        const resolvedPath = resolveTaskVarsInString(fp.path, taskId);
        const info = await requestFileInfo(resolvedPath);
        if (!info) return;
        fp.info = info;
        scheduleSaveState();
      } else if (action === "copy-first-line" || action === "copy-last-line") {
        const resolvedPath = resolveTaskVarsInString(fp.path, taskId);
        const res = await requestHeadTail(resolvedPath);
        if (!res) return;
        const text = action === "copy-first-line" ? res.first : res.last;
        if (!text) {
          showMessage("Êú™ÊâæÂà∞ÈùûÁ©∫Ë°å„ÄÇ");
          return;
        }
        copyToClipboard(text);
      }
    }

    // Á¨¨ÂõõÂàóÔºöÊìç‰ΩúÂ∫èÂàó & ËäÇÁÇπ
    if (type === "sequence-board") {
      const seqId = payload.sequenceId;
      const seq = appState.operation_sequences[seqId];
      if (!seq) return;

      if (action === "rename-sequence-board") {
        let newName = prompt("ËØ∑ËæìÂÖ•Êñ∞ÁöÑÊìç‰ΩúÂ∫èÂàóÂêçÁß∞Ôºö", seq.name || "");
        if (!newName) return;
        newName = newName.trim();
        if (!newName) {
          showMessage("Êìç‰ΩúÂ∫èÂàóÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫„ÄÇ");
          return;
        }

        const taskId = seq.task_id;
        const existingNames = sequenceNodesForTask(taskId)
          .filter(s => s.id !== seqId)
          .map(s => s.name);
        if (existingNames.includes(newName)) {
          showMessage("Âêå‰∏Ä‰ªªÂä°‰∏ãÊìç‰ΩúÂ∫èÂàóÂêçÁß∞‰∏çÂæóÈáçÂ§ç„ÄÇ");
          return;
        }

        seq.name = newName;
        scheduleSaveState();
      } else if (action === "delete-sequence-board") {
        const ok = confirm("Á°ÆÂÆöË¶ÅÂà†Èô§ËØ•Êìç‰ΩúÂ∫èÂàóÁîªÊùøÂêóÔºü");
        if (!ok) return;
        delete appState.operation_sequences[seqId];
        scheduleSaveState();
      } else if (action === "generate-code") {
        const task = getCurrentTask();
        if (!task) {
          showMessage("‰ªªÂä°‰∏çÂ≠òÂú®„ÄÇ");
          return;
        }
        await requestGenerateCode(task.id, seqId);
      } else if (action === "run-sequence") {
        const task = getCurrentTask();
        if (!task) {
          showMessage("‰ªªÂä°‰∏çÂ≠òÂú®„ÄÇ");
          return;
        }
        await requestRunSequence(task.id, seqId);
      } else if (action === "copy-sequence-full") {
        const seq = appState.operation_sequences[seqId];
        if (!seq) return;

        const task = appState.tasks[seq.task_id];

        copiedSequenceTemplate = {
          seq: JSON.parse(JSON.stringify(seq)),
          fromTaskId: seq.task_id,
          fromTaskName: task ? task.name : "(Êú™Áü•‰ªªÂä°)"
        };

        showMessage(
          `Â∑≤Â§çÂà∂Êìç‰ΩúÂ∫èÂàóÔºàÊù•Ëá™‰ªªÂä°Ôºö${copiedSequenceTemplate.fromTaskName}ÔºâÔºåÂèØÂú®‰ªªÊÑèÊñá‰ª∂ÁªÑ‰∏äÁ≤òË¥¥„ÄÇ`
        );
      }
    } else if (type === "root-node" || type === "op-node") {
      const seqId = payload.sequenceId;
      const nodeId = payload.nodeId;
      const seq = appState.operation_sequences[seqId];
      if (!seq) return;
      const nodes = seq.nodes || [];
      const idx = nodes.findIndex(n => n.id === nodeId);
      if (action === "set-executed-false") {
        setNodeExecutedWithPropagation(seqId, nodeId, false);
        return;
      }
      if (action === "set-executed-true") {
        setNodeExecutedWithPropagation(seqId, nodeId, true);
        return;
      }
      if (idx === -1) return;
      if (action === "toggle-freeze-node") {
        const node = nodes[idx];
        const newStatus = !node.frozen; // ÂàáÊç¢Áä∂ÊÄÅ

        // ÈÄíÂΩíÂáΩÊï∞ÔºöËÆæÁΩÆËäÇÁÇπÂèäÂÖ∂ÊâÄÊúâÂêé‰ª£ÁöÑ frozen Áä∂ÊÄÅ
        function setFrozenRecursive(targetId, status) {
          // 1. ËÆæÁΩÆÂΩìÂâçËäÇÁÇπ
          const targetNode = nodes.find(n => n.id === targetId);
          if (targetNode) {
            targetNode.frozen = status;
            
            // 2. Êü•ÊâæÊâÄÊúâ‰ª•ÂΩìÂâçËäÇÁÇπ‰∏∫Áà∂ËäÇÁÇπÁöÑÂ≠êËäÇÁÇπÔºåÂπ∂ÈÄíÂΩí
            const children = nodes.filter(n => n.parent_id === targetId);
            children.forEach(child => {
              setFrozenRecursive(child.id, status);
            });
          }
        }

        // ÊâßË°åÈÄíÂΩíÊõ¥Êñ∞
        setFrozenRecursive(node.id, newStatus);
        
        // ‰øùÂ≠òÁä∂ÊÄÅ
        scheduleSaveState();
      } 

      // ========= Á∫øÊÄßÊèíÂÖ•ÔºöA -> C ÂèòÊàê A -> B -> CÔºàÊîØÊåÅÂ§öÂàÜÊîØÔºåB ÂèòÊàêÂÖ¨ÂÖ±ÂâçÁºÄÔºâ =========
      if (action === "insert-linear-node") {
        // ÊâÄÊúâÂΩìÂâç‰ª•ËØ•ËäÇÁÇπ‰∏∫Áà∂ËäÇÁÇπÁöÑÂ≠êËäÇÁÇπ
        const children = nodes.filter(n => n.parent_id === nodeId);

        const newNode = {
          id: createId(),
          node_type: "op",
          name: "Êñ∞ËäÇÁÇπ",
          function_name: "",
          params_json: "{}",
          description: "",
          result_save_path: "",
          executed: false,
          parent_id: nodeId   // ÂÖàÊåÇÂú®ÂΩìÂâçËäÇÁÇπ‰∏ãÈù¢
        };

        // Âú®Á∫øÊÄßÈ°∫Â∫è‰∏äÊèíÂà∞ÂΩìÂâçËäÇÁÇπ‰πãÂêé
        nodes.splice(idx + 1, 0, newNode);

        // ÊâÄÊúâÂéüÊú¨ÁöÑÂ≠êËäÇÁÇπÁªü‰∏Ä‰∏ãÊ≤âÂà∞Êñ∞ËäÇÁÇπ‰∏ãÈù¢
        children.forEach(child => {
          child.parent_id = newNode.id;
        });

        scheduleSaveState();

      // ========= ÂéüÊù•ÁöÑ‚ÄúÊèíÂÖ•Â≠êËäÇÁÇπ‚ÄùÔºöÂè™Â§ö‰∏Ä‰∏™ÂàÜÊîØÔºå‰∏çÂä®Â∑≤ÊúâÂ≠êËäÇÁÇπ =========
      } else if (action === "insert-child-node") {
        const newNode = {
          id: createId(),
          node_type: "op",
          name: "Êñ∞ËäÇÁÇπ",
          function_name: "",
          params_json: "{}",
          description: "",
          result_save_path: "",
          executed: false,
          parent_id: nodeId
        };
        nodes.splice(idx + 1, 0, newNode);
        scheduleSaveState();

      } else if (action === "insert-multi-child-nodes") {
        let countStr = prompt("ËØ∑ËæìÂÖ•Ë¶ÅÂàõÂª∫ÁöÑÂ≠êËäÇÁÇπÊï∞ÈáèÔºà2-5ÔºâÔºö", "2");
        if (!countStr) return;
        let count = parseInt(countStr, 10);
        if (isNaN(count)) count = 2;
        if (count < 2) count = 2;
        if (count > 5) count = 5;

        // ÊèíÂÖ•‰ΩçÁΩÆÔºöÂΩìÂâçËäÇÁÇπ‰πãÂêéÔºå‰∏îÂú®Â∑≤ÊúâÂ≠êËäÇÁÇπ‰πãÂêé
        let insertIndex = idx + 1;
        for (let i = nodes.length - 1; i > idx; i--) {
          if (nodes[i].parent_id === nodeId) {
            insertIndex = i + 1;
            break;
          }
        }

        const newNodes = [];
        for (let i = 0; i < count; i++) {
          newNodes.push({
            id: createId(),
            node_type: "op",
            name: "ÂàÜÊîØËäÇÁÇπ " + (i + 1),
            function_name: "",
            params_json: "{}",
            description: "",
            result_save_path: "",
            executed: false,
            parent_id: nodeId
          });
        }
        nodes.splice(insertIndex, 0, ...newNodes);
        scheduleSaveState();

      // ========= ÂéüÊúâÂà†Èô§ÔºöÂà†Ëá™Â∑± + ÊâÄÊúâÂêé‰ª£ÔºàÂç±Èô©Êìç‰ΩúÔºåËØ≠‰πâ‰∏çÂèòÔºâ =========
      } else if (action === "delete-child-node") {
        const node = nodes[idx];
        if (node.node_type === "root") {
          showMessage("Ê†πËäÇÁÇπ‰∏çÂÖÅËÆ∏Âà†Èô§„ÄÇ");
          return;
        }
        // Á∫ßËÅîÂà†Èô§ÔºöËØ•ËäÇÁÇπÂèäÂÖ∂ÊâÄÊúâÂêé‰ª£
        const toDelete = new Set();
        function markDescendants(id) {
          for (const n of nodes) {
            if (n.parent_id === id) {
              markDescendants(n.id);
            }
          }
          toDelete.add(id);
        }
        markDescendants(node.id);
        seq.nodes = nodes.filter(n => !toDelete.has(n.id));
        scheduleSaveState();

      // ========= Êñ∞Â¢ûÂà†Èô§ÔºöÊ°•Êé•Âà†Èô§ÔºàÂà†Èô§ÂΩìÂâçËäÇÁÇπÔºå‰ΩÜÊääÂ≠êËäÇÁÇπÊåÇÂõûÁà∂ËäÇÁÇπÔºâ =========
      } else if (action === "delete-child-node-bridge") {
        const node = nodes[idx];
        if (node.node_type === "root") {
          showMessage("Ê†πËäÇÁÇπ‰∏çÂÖÅËÆ∏Ê°•Êé•Âà†Èô§„ÄÇ");
          return;
        }

        const parentId = node.parent_id || null;
        const children = nodes.filter(n => n.parent_id === node.id);

        // Â≠êËäÇÁÇπÊåÇÂõûÁà∂ËäÇÁÇπÔºàÂ¶ÇÊûú parentId ‰∏∫ nullÔºåÂàôÂ≠êËäÇÁÇπÂèòÊàêÊñ∞ÁöÑÊ†πÔºâ
        children.forEach(child => {
          child.parent_id = parentId;
        });

        // Âà†Èô§ÂΩìÂâçËäÇÁÇπÊú¨Ë∫´
        nodes.splice(idx, 1);

        scheduleSaveState();

      } else if (action === "copy-op-node") {
        const node = nodes[idx];
        if (node.node_type !== "op") {
          showMessage("Âè™ÊúâÈùûÊ†πËäÇÁÇπÂèØ‰ª•Â§çÂà∂„ÄÇ");
          return;
        }
        copiedOpNodeTemplate = {
          node_type: "op",
          name: node.name,
          function_name: node.function_name,
          params_json: node.params_json,
          description: node.description,
          result_save_path: node.result_save_path || ""
        };
        // showMessage("Â∑≤Â§çÂà∂ËØ•ËäÇÁÇπÔºåÂèØÂú®‰ªªÊÑèËäÇÁÇπ‰∏äÂè≥ÈîÆÁ≤òË¥¥„ÄÇ");

      // ========= Êñ∞Â¢ûÔºöÁ∫øÊÄßÁ≤òË¥¥ =========
      } else if (action === "paste-op-node-linear") {
        if (!copiedOpNodeTemplate) {
          showMessage("ÂΩìÂâçÊ≤°ÊúâÂ∑≤Â§çÂà∂ÁöÑËäÇÁÇπ„ÄÇ");
          return;
        }
        const base = copiedOpNodeTemplate;
        const children = nodes.filter(n => n.parent_id === nodeId);

        const newNode = {
          id: createId(),
          node_type: "op",
          name: base.name,
          function_name: base.function_name,
          params_json: base.params_json,
          description: base.description,
          result_save_path: base.result_save_path || "",
          executed: false,
          parent_id: nodeId
        };

        // ÊèíÂà∞ÂΩìÂâçËäÇÁÇπÂêéÈù¢
        nodes.splice(idx + 1, 0, newNode);

        // ÊâÄÊúâÂéüÂ≠êËäÇÁÇπÁªü‰∏Ä‰∏ãÊ≤âÂà∞Êñ∞ËäÇÁÇπ‰∏ãÈù¢
        children.forEach(child => {
          child.parent_id = newNode.id;
        });

        scheduleSaveState();

      // ========= ‰øùÁïôÂéüÊúâ‚ÄúÂêë‰∏ãÁ≤òË¥¥Â∑≤Â§çÂà∂ËäÇÁÇπ‚ÄùËØ≠‰πâÔºöÊñ∞ÂàÜÊîØ =========
      } else if (action === "paste-op-node-below") {
        if (!copiedOpNodeTemplate) {
          showMessage("ÂΩìÂâçÊ≤°ÊúâÂ∑≤Â§çÂà∂ÁöÑËäÇÁÇπ„ÄÇ");
          return;
        }
        const base = copiedOpNodeTemplate;
        const newNode = {
          id: createId(),
          node_type: "op",
          name: base.name,
          function_name: base.function_name,
          params_json: base.params_json,
          description: base.description,
          result_save_path: base.result_save_path || "",
          executed: false,
          parent_id: nodeId
        };
        nodes.splice(idx + 1, 0, newNode);
        scheduleSaveState();
      }
    }
  }

  // ===========
  // ÁªëÂÆöÂè≥ÈîÆ‰∫ã‰ª∂
  // ===========

  document.getElementById("task-tree").addEventListener("contextmenu", e => {
    e.preventDefault();
    const node = e.target.closest("[data-node-type]");
    if (!node) {
      showContextMenu("task-empty", {}, e.pageX, e.pageY);
      return;
    }
    const type = node.dataset.nodeType;
    if (type === "directory") {
      showContextMenu("directory", { id: node.dataset.id }, e.pageX, e.pageY);
    } else if (type === "task") {
      showContextMenu("task", { id: node.dataset.id }, e.pageX, e.pageY);
    }
  });

  document.getElementById("file-groups").addEventListener("contextmenu", e => {
    e.preventDefault();
    const groupEl = e.target.closest(".file-group");
    const pathEl = e.target.closest(".file-path-row");
    if (pathEl && groupEl) {
      showContextMenu(
        "file-path",
        {
          groupId: groupEl.dataset.groupId,
          filePathId: pathEl.dataset.filePathId
        },
        e.pageX,
        e.pageY
      );
    } else if (groupEl) {
      showContextMenu(
        "file-group",
        { groupId: groupEl.dataset.groupId },
        e.pageX,
        e.pageY
      );
    } else {
      showContextMenu("group-empty", {}, e.pageX, e.pageY);
    }
  });

  document.getElementById("operation-area").addEventListener("contextmenu", e => {
    e.preventDefault();
    const sequenceHeader = e.target.closest(".sequence-header");
    const nodeEl = e.target.closest(".sequence-node");
    if (sequenceHeader) {
      showContextMenu(
        "sequence-board",
        { sequenceId: sequenceHeader.dataset.sequenceId },
        e.pageX,
        e.pageY
      );
    } else if (nodeEl) {
      const nodeType = nodeEl.dataset.nodeType;
      if (nodeType === "root-node") {
        showContextMenu(
          "root-node",
          {
            sequenceId: nodeEl.dataset.sequenceId,
            nodeId: nodeEl.dataset.nodeId
          },
          e.pageX,
          e.pageY
        );
      } else if (nodeType === "op-node") {
        showContextMenu(
          "op-node",
          {
            sequenceId: nodeEl.dataset.sequenceId,
            nodeId: nodeEl.dataset.nodeId
          },
          e.pageX,
          e.pageY
        );
      }
    }
  });

  // ===========
  // ÂàóÂÆΩÊãñÂä®
  // ===========

  function setupResizeHandles() {
    const mainEl = document.getElementById("main");
    const handles = document.querySelectorAll(".resize-handle");
    let isDragging = false;
    let dragIndex = null;
    let startX = 0;
    let startWidths = null;

    handles.forEach(handle => {
      handle.addEventListener("mousedown", e => {
        e.preventDefault();
        isDragging = true;
        dragIndex = parseInt(handle.dataset.handle, 10) - 1;
        startX = e.clientX;
        startWidths = getCurrentColumnWidths();
      });
    });

    document.addEventListener("mousemove", e => {
      if (!isDragging || dragIndex == null) return;

      const dx = e.clientX - startX;
      const mainRect = mainEl.getBoundingClientRect();
      const totalWidth = mainRect.width;
      if (!totalWidth) return;

      const deltaPercent = dx / totalWidth * 100;

      const widths = startWidths.slice();
      const left = widths[dragIndex];
      const right = widths[dragIndex + 1];
      const pair = left + right;

      // ÊØèÂàóÊúÄÂ∞èÂÆΩÂ∫¶ÔºàÁôæÂàÜÊØîÔºâ
      const MIN = 10;
      if (pair <= MIN * 2) return; // ÊûÅÁ´ØÂÖúÂ∫ïÔºàÊ≠£Â∏∏‰∏ç‰ºöÂèëÁîüÔºâ

      // Âú® [MIN, pair - MIN] ‰πãÈó¥ÁßªÂä® newLeftÔºå‰øùËØÅ‰∏§ËæπÈÉΩ‰∏ç‰ºöÂ∞è‰∫é MIN
      let newLeft = left + deltaPercent;
      newLeft = Math.max(MIN, Math.min(pair - MIN, newLeft));
      const newRight = pair - newLeft;

      widths[dragIndex] = newLeft;
      widths[dragIndex + 1] = newRight;

      applyColumnWidths(widths);
    });

    document.addEventListener("mouseup", () => {
      if (isDragging) {
        isDragging = false;
        const widths = getCurrentColumnWidths();
        saveWidthsToLocal(widths);
      }
      dragIndex = null;
    });
  }

  // ======================
  // ‰ªªÂä°ÂèòÈáèÂºπÁ™óÔºàÂèØÊãñÂä® textareaÔºâ
  // ======================
  (function setupTaskVarsModal(){
    const modal = document.getElementById("taskvars-modal");
    const ta = document.getElementById("taskvars-textarea");
    const btnClose = document.getElementById("taskvars-close");
    const btnCancel = document.getElementById("taskvars-cancel");
    const btnSave = document.getElementById("taskvars-save");
    const backdrop = document.getElementById("taskvars-backdrop");

    function openWithText(text){
      ta.value = (text ?? "").toString().trim();   // ‚úÖ ÂõûÂÜôÊúÄÁªàÂÄºÔºàtrimÔºâ
      modal.style.display = "flex";
      setTimeout(() => ta.focus(), 0);
    }

    function close(){
      modal.style.display = "none";
    }

    function save(){
      ta.value = (ta.value || "").trim();          // ‚úÖ ÂõûÂÜôÊúÄÁªàÂÄºÔºàtrimÔºâ

      let obj = null;
      try {
        obj = ta.value ? JSON.parse(ta.value) : {};
      } catch (e) {
        showMessage("‰ªªÂä°ÂèòÈáè‰∏çÊòØÂêàÊ≥ï JSONÔºåÊú™‰øùÂ≠ò„ÄÇ");
        return;
      }
      if (!obj || typeof obj !== "object" || Array.isArray(obj)) {
        showMessage("‰ªªÂä°ÂèòÈáèÂøÖÈ°ªÊòØ JSON ÂØπË±°Ôºö{...}ÔºåÊú™‰øùÂ≠ò„ÄÇ");
        return;
      }

      const task = getCurrentTask();
      if (!task) {
        showMessage("‰ªªÂä°‰∏çÂ≠òÂú®„ÄÇ");
        return;
      }
      task.vars = obj;
      scheduleSaveState(); // ‚úÖ ‰ªçÁÑ∂Ëµ∞‰Ω†Áé∞ÊúâÁöÑ‰øùÂ≠ò/Êí§ÈîÄ‰ΩìÁ≥ª
      close();
      showMessage("‰ªªÂä°ÂèòÈáèÂ∑≤‰øùÂ≠ò„ÄÇ");
    }

    btnClose.addEventListener("click", close);
    btnCancel.addEventListener("click", close);
    backdrop.addEventListener("click", close);
    btnSave.addEventListener("click", save);

    // Êö¥Èú≤‰∏Ä‰∏™ÂÖ®Â±ÄÂáΩÊï∞ÁªôÊåâÈíÆË∞ÉÁî®
    window.__openTaskVarsModal = openWithText;
  })();
  // ===========
  // È°∂ÈÉ®ÊåâÈíÆ
  // ===========

  const btnTaskVars = document.getElementById("btn-task-vars");
  if (btnTaskVars) {
    btnTaskVars.addEventListener("click", () => {
      const task = getCurrentTask();
      if (!task) {
        showMessage("ËØ∑ÂÖàÂú®Â∑¶‰æßÈÄâÊã©‰∏Ä‰∏™‰ªªÂä°„ÄÇ");
        return;
      }

      // ÊääÂΩìÂâç vars Ê†ºÂºèÂåñÊàê JSON ÊñáÊú¨ÔºåÂ°ûËøõÂºπÁ™ó textarea
      const currentVars = task.vars || {};
      const initial = JSON.stringify(currentVars, null, 2);

      // ÊâìÂºÄÂºπÁ™óÔºàËøô‰∏™ÂáΩÊï∞Êù•Ëá™‰Ω†Êñ∞Â¢ûÁöÑ setupTaskVarsModalÔºâ
      if (window.__openTaskVarsModal) {
        window.__openTaskVarsModal(initial);
      } else {
        showMessage("‰ªªÂä°ÂèòÈáèÂºπÁ™óÊú™ÂàùÂßãÂåñÔºöËØ∑Á°ÆËÆ§Â∑≤Ê∑ªÂä† taskvars-modal HTML + setupTaskVarsModal() JS„ÄÇ");
      }
    });
  }

  const btnUndo = document.getElementById("btn-undo");
  if (btnUndo) {
    btnUndo.addEventListener("click", () => {
      undoLastOperation();
    });
  }

  const btnRedo = document.getElementById("btn-redo");
  if (btnRedo) {
    btnRedo.addEventListener("click", () => {
      redoLastOperation();
    });
  }

  document.getElementById("btn-save").addEventListener("click", () => {
    saveStateToServer();
  });

  document.getElementById("btn-reload").addEventListener("click", () => {
    loadStateFromServer();
  });

  // ===========
  // Ê∏≤ÊüìÂÖ•Âè£
  // ===========

  function renderAll() {
    renderTaskTree();
    renderFileGroups();
    renderFieldStructure();
    renderOperationArea();
  }

  // ===========
  // ÂàùÂßãÂåñ
  // ===========

  (function init() {
    const widths = loadWidthsFromLocal();
    if (widths) {
      applyColumnWidths(widths);
    }
    setupResizeHandles();
    loadStateFromServer();
  })();
</script>
</body>
</html>
